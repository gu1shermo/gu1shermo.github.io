<h1 id="la-pratique-du-livecoding-techniques-fondamentales">La pratique
du <em>livecoding</em>: techniques fondamentales</h1>
<div class="epigraph">
<p>Le <em>shader</em>, c’est un programme, un morceau de code qui décrit
généralement une matière. Au-delà du rendu d’un simple « matériau »,
c’est même une étape qui va permettre de représenter de la 3D sur nos
écrans 2D.</p>
<p><em>Flopine</em></p>
</div>
<h2 id="introduction">Introduction</h2>
<p>Bien qu’à ATI beaucoup d’entre nous soyons habitués à manipuler les
<em>fragment shaders</em> avec les <em>nodes</em><a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>,
ceux-ci sont en réalité des programmes écrits pour s’exécuter sur la
carte graphique. Les <em>fragment shaders</em>, également connus sous le
nom de <em>pixel shaders</em>, sont responsables de la production d’une
couleur unique pour chaque fragment<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> rendu. Dans la plupart
des cas, un fragment correspond à un <em>pixel</em> affiché à l’écran.
La couleur du <em>pixel</em> est stockée dans des canaux séparés. Si on
considère le codage de couleurs RGBA, un premier canal représentera le
rouge, et les trois autres canaux décriront respectivement le vert, le
bleu et l’opacité. Chaque canal est représenté par des valeurs variant
de <span class="math inline">\(0.0\)</span> à <span
class="math inline">\(1.0\)</span>. Par exemple, <span
class="math inline">\((0.0, 0.0, 0.0, 1.0)\)</span> représentera le noir
opaque, <span class="math inline">\((1.0, 1.0, 1.0, 1.0)\)</span>
représentera le blanc opaque et <span class="math inline">\((1.0, 0.0,
0.0, 0.5)\)</span> représentera le rouge pur avec <span
class="math inline">\(50\%\)</span> d’opacité.</p>
<p>Pour récapituler, un <em>fragment shader</em> est un programme
contenant une seule fonction. Cette fonction reçoit les coordonnées uv
d’un <em>quad</em> représentant l’intégralité de l’écran en tant que
paramètre d’entrée. Elle calcule ensuite la couleur de rendu pour chaque
<em>pixel</em>.</p>
<p>Dans la pratique du <em>livecoding</em>, il est essentiel de pouvoir
coder « de mémoire », car en compétition, selon les règles en vigueur,
il peut être interdit de consulter Internet en cas d’oubli, tout comme
l’utilisation de textures peut être proscrite.</p>
<p>Dans cette section, nous nous efforcerons de décrire les principales
techniques de développement en <em>live</em> d’un <em>shader</em> tout
en abordant les concepts mathématiques sous-jacents. Ces principes
mathématiques sont indispensables pour comprendre la logique à laquelle
obéissent nos <em>shaders</em>. Sans cela, nous perdrons une liberté
créative ainsi que la capacité de débogage. Il n’est pas rare de se
retrouver sur scène devant un écran totalement noir sans parvenir à
trouver la source de l’anomalie. De plus, contrairement au développement
sur CPU, les fonctions d’affichage telles que en langage C ne sont pas
disponibles lors de la programmation pour la carte graphique.</p>
<h3 class="unnumbered"
id="transition-entre-les-langages-facilité-et-subtilités">Transition
entre les langages : facilité et subtilités</h3>
<p>Il existe plusieurs langages pour écrire un <em>shader</em> : GLSL,
HLSL, Cg ou encore MSL. Le choix du langage dépend de facteurs tels que
la performance recherchée, la compatibilité avec la plate-forme ou les
logiciels choisis pour le projet.</p>
<p>Cependant, le point commun entre tous ces langages est qu’ils
possèdent une syntaxe héritée du langage C. On y retrouve le concept de
types, de déclarations de fonctions, de structures, etc. Une fois que
l’on maîtrise la syntaxe de l’un de ces langages, il est très aisé de
passer d’un langage à un autre ; il suffit simplement de s’adapter à
quelques subtilités. Par exemple, le type qui décrit les vecteurs à
trois dimensions peut être dans un langage et dans un autre. De même,
les nombres flottants () peuvent nécessiter un point () ou la lettre en
suffixe ().</p>
<h2 id="lespace-uv">L’espace uv</h2>
<p>L’espace uv est un concept fondamental pour comprendre les
<em>shaders</em>, et tous les artistes en sont déjà au moins familiers,
sans avoir nécessairement besoin de comprendre les mathématiques qui se
cachent derrière, notamment lorsqu’ils appliquent des textures à la
surface de leurs modèles 3D.</p>
<p>Les textures apparaissent généralement en deux dimensions (bien qu’il
existe également des textures 1D et 3D) et sont décrites par une image.
Elles peuvent aussi bien concerner l’aspect visuel de « l’apparence » de
l’objet avec la <em>diffuse map</em><a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> que l’illusion de relief
avec la <em>normal map</em><a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a>. Le terme anglais
<em>map</em> correspond au terme français cartographie. Cette
terminologie provient probablement de l’analogie avec la cartographie
géographique, où des informations sont représentées sur une carte en
deux dimensions pour refléter des éléments de la réalité en trois
dimensions.</p>
<p>Les textures existent dans un espace en deux dimensions, et à chaque
sommet, on associe une coordonnée uv comprise entre <span
class="math inline">\(0\)</span> et <span
class="math inline">\(1\)</span>, qui désigne un <em>texel</em><a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> de la texture. Tout comme n’importe
quel attribut associé à un sommet, ces valeurs de coordonnée de texture
seront interpolées lors de la rastérisation.</p>
<figure id="maya_text01">
<img src="images/shaders/maya_text00.png" />
<img src="images/shaders/maya_text01.png" />
<figcaption>Texture sur un <em>mesh</em> dans Maya</figcaption>
</figure>
<p>Dans le contexte du <em>livecoding</em>, nous ne disposons pas d’un
modèle 3D complet, mais seulement de deux triangles formant un plan qui
remplit tout l’écran. Les données d’entrée du <em>shader</em> nous
fournissent par défaut la résolution du <em>viewport</em> () ainsi que
les coordonnées de chaque <em>pixel</em> (). En divisant ces coordonnées
par la résolution, nous obtenons une valeur normalisée, comprise entre
<span class="math inline">\(0\)</span> et <span
class="math inline">\(1\)</span>, correspondant à nos coordonnées de
texture.</p>
<div class="sourceCode" id="cb1" data-language="GLSL"
data-caption="uv avec l&#39;origine en bas à gauche" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>uv<span class="op">,</span><span class="fl">0.</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Dans l’image <a href="#meduse_00" data-reference-type="ref"
data-reference="meduse_00">[meduse_00]</a>, nous avons une
représentation visuelle de l’espace uv. Les coordonnées horizontales
sont codées dans la couleur rouge tandis que les coordonnées verticales
sont codées dans la couleur verte. L’origine du repère étant située en
bas à gauche, nous observons du noir. Le point en bas à droite est d’un
rouge pur car sa coordonnée en <span class="math inline">\(X\)</span>
vaut <span class="math inline">\(1\)</span> et sa coordonnée en <span
class="math inline">\(Y\)</span> vaut <span
class="math inline">\(0\)</span>. À l’inverse, la couleur en haut à
gauche du canvas est d’un vert pur. En haut à droite, nous obtenons un
jaune pur car les coordonnées <span class="math inline">\(X\)</span> et
<span class="math inline">\(Y\)</span> valent toutes les deux <span
class="math inline">\(1\)</span>. Tous les <em>pixels</em>
intermédiaires possèdent une couleur interpolée dépendante de leur
distance par rapport à chacun des quatre coins. Cela est effectué
automatiquement lors de l’étape de rastérisation.</p>
<figure id="meduse_01">
<img src="images/meduse/meduse_00.JPG" />
<img src="images/meduse/meduse_01.JPG" />
<figcaption>Repère centré et orthonormé</figcaption>
</figure>
<p>Pour une meilleure visualisation, nous pouvons observer séparément
les coordonnées en abscisse (voir <a href="#meduse_uv_00"
data-reference-type="ref"
data-reference="meduse_uv_00">[meduse_uv_00]</a>) et en ordonnée (voir
<a href="#meduse_uv_01" data-reference-type="ref"
data-reference="meduse_uv_01">1.3</a>).</p>
<figure id="meduse_uv_01">
<img src="images/meduse/meduse_uv_00.JPG" />
<img src="images/meduse/meduse_uv_01.JPG" />
<figcaption>uv en y</figcaption>
</figure>
<p>Cet espace uv, ou coordonnées uv, désigne l’espace dans lequel nos
<em>shaders</em> vont dessiner. Cette notion est cruciale car nous
n’appliquons pas les transformations à la forme dessinée elle-même, mais
plutôt à l’espace dans lequel cette forme est dessinée (voir <a
href="#animcarre" data-reference-type="ref"
data-reference="animcarre">1.4</a>).</p>
<figure id="animcarre">
<img src="images/shaders/animcarre00.PNG" />
<img src="images/shaders/animcarre01.PNG" />
<img src="images/shaders/animcarre02.PNG" />
<figcaption>Ce n’est pas le rectangle qui est animé mais bien l’espace
uv</figcaption>
</figure>
<p>Il est souvent préférable d’utiliser un espace centré et orthonormé<a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a> pour faciliter le dessin. Ainsi, le
code d’un <em>shader</em> commencera souvent de la même manière :</p>
<div class="sourceCode" id="cb2" data-language="GLSL"
data-caption="Repère centré et orthonormé" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec2</span> uv <span class="op">=</span> <span class="op">(</span>fragCoord<span class="fl">-.5</span><span class="op">*</span>iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">)/</span>iResolution<span class="op">.</span><span class="fu">xx</span><span class="op">;</span> <span class="co">//  permet de centrer nos coordonnees</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>L’espace résultant (voir <a href="#meduse_01"
data-reference-type="ref" data-reference="meduse_01">1.2</a>) trouve son
origine au centre, et les coordonnées varient entre <span
class="math inline">\(-0.5\)</span> et <span
class="math inline">\(+0.5\)</span>. Comme précédemment, la couleur
noire représente des valeurs négatives ou nulles. Le vert indique des
valeurs négatives en X et positives en Y, le rouge indique des valeurs
positives en X et négatives en Y, et enfin le jaune indique des valeurs
positives sur les deux axes. Avec une pratique régulière, ces
associations de couleurs deviennent presque instinctives, et
l’association entre les couleurs et les axes ne demande plus d’efforts
de réflexion.</p>
<h2 id="les-fonctions-de-distance-signée">Les fonctions de distance
signée</h2>
<p>Le deuxième concept essentiel à assimiler est le principe
mathématique d’une fonction de distance signée. Cette fonction est
souvent désignée par l’appellation anglaise <em>signed distance
function</em>, abrégée en SDF, que l’on retrouve couramment sur Internet
et dans la littérature. Ce sont elles qui vont nous permettre de décrire
les objets de notre scène mais aussi de les déformer, de les répéter,
etc.</p>
<h3 class="unnumbered" id="définition">Définition</h3>
<p>Schématiquement, une SDF est une fonction qui calcule une valeur
représentant la distance d’un point par rapport à une surface donnée. Le
signe de la valeur retournée nous indique si le point est situé à
l’intérieur ou à l’extérieur de la surface. Ce qui suit est une
explication équivalente, mais formulée en termes mathématiques.</p>
<p>Soit <span class="math inline">\(S\)</span> la surface de référence,
et <span class="math inline">\(p\)</span> un point dans l’espace. La
fonction de distance signée <span class="math inline">\(d(p,S)\)</span>
évalue la distance du point <span class="math inline">\(p\)</span> à la
surface <span class="math inline">\(S\)</span>, avec les propriétés
suivantes :</p>
<ul>
<li><p>Si le point <span class="math inline">\(p\)</span> est à
l’extérieur de la surface <span class="math inline">\(S\)</span>, la
distance est positive (<span
class="math inline">\(&gt;0\)</span>).</p></li>
<li><p>Si le point <span class="math inline">\(p\)</span> est à
l’intérieur de la surface <span class="math inline">\(S\)</span>, la
distance est négative (<span
class="math inline">\(&lt;0\)</span>).</p></li>
<li><p>Si le point <span class="math inline">\(p\)</span> est sur la
surface S, la distance est nulle (<span
class="math inline">\(=0\)</span>).</p></li>
</ul>
<p>Notons que dans un souci de simplification visuelle, nous nous
focaliserons sur les SDF en deux dimensions. Cependant, il est important
de noter que les mêmes principes s’appliquent également dans un espace
tridimensionnel. Dans les images ci-dessous (voir <a href="#sdf_00"
data-reference-type="ref" data-reference="sdf_00">[sdf_00]</a>, <a
href="#sdf_01" data-reference-type="ref"
data-reference="sdf_01">1.5</a>, <a href="#sdf_02"
data-reference-type="ref" data-reference="sdf_02">[sdf_02]</a> et <a
href="#sdf_03" data-reference-type="ref"
data-reference="sdf_03">1.6</a>), nous visualisons quatre SDF, chacune
représentant une forme différente (un cercle, une étoile, un cœur et une
vague sinusoïdale). Ces fonctions, créées par Inigo Quilez, sont
largement utilisées dans la création de <em>shaders</em>. De nombreuses
formes ont été codées et, comme nous le verrons un peu plus tard, il est
très facile de les combiner entre elles.</p>
<figure id="sdf_01">
<img src="images/sdf/sdf_00.jpg" />
<img src="images/sdf/sdf_01.jpg" />
<figcaption>SDF d’une étoile</figcaption>
</figure>
<figure id="sdf_03">
<img src="images/sdf/sdf_02.jpg" />
<img src="images/sdf/sdf_03.jpg" />
<figcaption>SDF d’une vague sinusoïdale</figcaption>
</figure>
<p>Sur les images, la couleur orangée représente l’espace qui se trouve
à l’extérieur de la forme, tandis que la couleur bleutée représente
l’espace à l’intérieur de la forme. Dans les deux cas, plus l’on se
rapproche de la surface de la forme, plus la couleur s’assombrit. Ceci
est logique puisque plus l’on se rapproche de la surface, plus la valeur
de la distance tend vers zéro. Le contour blanc est là pour indiquer que
l’on se trouve exactement sur la surface de la forme. Les ondulations
que l’on observe autour de la forme symbolisent la distance proprement
dite. Une analogie que j’aime employer est celle avec le sonar <a
href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> utilisé par les sous-marins pour
détecter des objets sous l’eau. Grâce à cette fonction de distance,
l’utilisateur peut contrôler à la fois la taille de la forme et
l’épaisseur de son contour.</p>
<h3 class="unnumbered"
id="opérations-booléennes-avec-les-sdf">Opérations booléennes avec les
SDF</h3>
<p>Nous venons de voir comment dessiner des formes 2D primitives telles
que des cercles, des étoiles et des carrés, mais nous pouvons utiliser
les opérations SDF 2D pour créer des formes plus complexes en combinant
des formes primitives.</p>
<p>Les SDF possèdent une propriété mathématique très intéressante : il
est très commode d’utiliser des opérations booléennes pour combiner les
formes entre elles. Les trois opérateurs booléens sont l’union,
l’intersection et la soustraction. L’union permet d’assembler deux
objets, l’intersection est le résultat de la partie commune entre les
deux objets, et la soustraction est le résultat du premier objet auquel
on enlève le second objet. Les illustrations qui suivent considèrent
deux objets: un carré et un cercle. En code, ces opérations booléennes
sont triviales à traduire.</p>
<h5 class="unnumbered" id="lunion">L’union</h5>
<p>Pour l’union, on utilise la fonction avec les deux SDF en tant
qu’arguments (voir <a href="#sdf_op_00" data-reference-type="ref"
data-reference="sdf_op_00">[sdf_op_00]</a>).</p>
<div class="sourceCode" id="cb3" data-language="GLSL"
data-caption="Union" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> d1 <span class="op">=</span> <span class="fu">sdCircle</span><span class="op">(</span>uv<span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">));</span> <span class="co">// le cercle</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> d2 <span class="op">=</span> <span class="fu">sdSquare</span><span class="op">(</span>uv<span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span> <span class="co">// le carre</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> res<span class="op">;</span> <span class="co">// result</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> d2<span class="op">);</span> <span class="co">// union</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure id="sdf_op_01">
<img src="images/sdf/sdf_op_00.JPG" />
<img src="images/sdf/sdf_op_01.JPG" />
<figcaption>Intersection</figcaption>
</figure>
<h5 class="unnumbered" id="lintersection">L’intersection</h5>
<p>Pour l’intersection on utilise (voir <a href="#sdf_op_01"
data-reference-type="ref" data-reference="sdf_op_01">1.7</a>).</p>
<div class="sourceCode" id="cb4" data-language="GLSL"
data-caption="Intersection" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>d1<span class="op">,</span> d2<span class="op">);</span> <span class="co">// intersection</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h5 class="unnumbered" id="la-soustraction">La soustraction</h5>
<p>Pour la soustraction, on utilise toujours la fonction , mais avec
l’inverse de la seconde forme comme deuxième argument (qu’on décrit avec
l’opérateur ). En effet, la soustraction est une intersection entre la
première forme et la « non » seconde forme (voir <a href="#sdf_op_02"
data-reference-type="ref"
data-reference="sdf_op_02">[sdf_op_02]</a>).</p>
<div class="sourceCode" id="cb5" data-language="GLSL"
data-caption="Soustraction" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">(...)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>d1<span class="op">,</span> <span class="op">-</span>d2<span class="op">);</span> <span class="co">// soustraction</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h5 class="unnumbered" id="le-ou-exclusif">Le « ou exclusif »</h5>
<p>Pour l’opérateur on utilise une combinaison de et (voir <a
href="#sdf_op_03" data-reference-type="ref"
data-reference="sdf_op_03">1.8</a>).</p>
<div class="sourceCode" id="cb6" data-language="GLSL" data-caption="XOR"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">(...)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> <span class="bu">max</span><span class="op">(</span><span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> d2<span class="op">),</span> <span class="op">-</span><span class="bu">max</span><span class="op">(</span>d1<span class="op">,</span> d2<span class="op">));</span> <span class="co">// xor</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure id="sdf_op_03">
<img src="images/sdf/sdf_op_02.JPG" />
<img src="images/sdf/sdf_op_03.JPG" />
<figcaption>XOR</figcaption>
</figure>
<p>Tous ces opérateurs booléens ont été réécrits par Inigo Quilez pour
prendre en compte un paramètre de lissage<a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
(voir <a href="#sdf_op_04" data-reference-type="ref"
data-reference="sdf_op_04">[sdf_op_04]</a> et <a href="#sdf_op_05"
data-reference-type="ref" data-reference="sdf_op_05">1.9</a>).</p>
<div class="sourceCode" id="cb7" data-language="GLSL"
data-caption="Smoothness" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// smooth min</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> <span class="fu">smin</span><span class="op">(</span><span class="dt">float</span> a<span class="op">,</span> <span class="dt">float</span> b<span class="op">,</span> <span class="dt">float</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">float</span> h <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span><span class="fl">0.5+0.5</span><span class="op">*(</span>b<span class="op">-</span>a<span class="op">)/</span>k<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">return</span> <span class="bu">mix</span><span class="op">(</span>b<span class="op">,</span> a<span class="op">,</span> h<span class="op">)</span> <span class="op">-</span> k<span class="op">*</span>h<span class="op">*(</span><span class="fl">1.0</span><span class="op">-</span>h<span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// smooth max</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> <span class="fu">smax</span><span class="op">(</span><span class="dt">float</span> a<span class="op">,</span> <span class="dt">float</span> b<span class="op">,</span> <span class="dt">float</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">return</span> <span class="op">-</span><span class="fu">smin</span><span class="op">(-</span>a<span class="op">,</span> <span class="op">-</span>b<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure id="sdf_op_05">
<img src="images/sdf/sdf_op_04.JPG" />
<img src="images/sdf/sdf_op_05.JPG" />
<figcaption>Intersection smooth</figcaption>
</figure>
<p>Inigo Quilez a également développé des fonctions pour agir
directement sur l’espace uv, permettant de dessiner rapidement tout en
améliorant les performances. Par exemple, si l’on souhaite créer une
scène symétrique, il peut être utile d’utiliser la fonction . Cette
fonction crée une forme 2D dupliquée le long de l’axe <span
class="math inline">\(X\)</span> à l’aide du SDF utilisé (voir <a
href="#sdf_op_06" data-reference-type="ref"
data-reference="sdf_op_06">[sdf_op_06]</a>). De même, si nous voulons
dessiner un nombre infini d’objets 2D sur un ou plusieurs axes, la
fonction est parfaitement adaptée (voir <a href="#sdf_op_07"
data-reference-type="ref" data-reference="sdf_op_07">1.10</a>).</p>
<figure id="sdf_op_07">
<img src="images/sdf/sdf_op_06.JPG" />
<img src="images/sdf/sdf_op_07.JPG" />
<figcaption>Répétition de l’espace</figcaption>
</figure>
<p>Pour des raisons de lisibilité, nous avons traité la notion des SDF
dans un espace bidimensionnel. Bien évidemment, tous ces concepts
fonctionnent de la même manière dans un espace tridimensionnel. Il
existe des fonctions pour décrire des formes 3D primitives comme des
cubes ou des sphères, mais aussi des formes plus complexes comme des
pyramides ou des tores. Les opérations booléennes demeurent inchangées
(voir <a href="#union" data-reference-type="ref"
data-reference="union">[union]</a>, <a href="#intersection"
data-reference-type="ref"
data-reference="intersection">[intersection]</a>, <a
href="#soustraction" data-reference-type="ref"
data-reference="soustraction">1.11</a>), et en les combinant, nous
pouvons obtenir facilement des formes évoluées (voir <a href="#sdf00"
data-reference-type="ref" data-reference="sdf00">[sdf00]</a> et <a
href="#shaderat01" data-reference-type="ref"
data-reference="shaderat01">1.12</a>).</p>
<figure id="soustraction">
<img src="images//sdf/union.png" />
<img src="images//sdf/intersection.png" />
<img src="images//sdf/soustraction.png" />
<figcaption>Soustraction 3D</figcaption>
</figure>
<figure id="shaderat01">
<img src="images/sdf/sdf00.png" />
<img src="images/shaders/shaderatelier_01.jpg" />
<figcaption>Deux sphères moins un cylindre</figcaption>
</figure>
<h2 id="exploration-de-la-construction-dune-sdf">Exploration de la
construction d’une SDF</h2>
<p>Après avoir expliqué en détail ce qu’est une SDF et comment elle est
utilisée dans le domaine du <em>creative coding</em>, il me paraissait
pertinent d’approfondir la compréhension en examinant la fabrication
mathématique de ces fonctions. Bien que de nombreux créateurs de
<em>shaders</em> se contentent souvent d’adopter une SDF préexistante
développée par des figures reconnues comme Inigo Quilez, il est
regrettable de constater que cela se fait souvent au détriment d’une
réelle compréhension de la démonstration mathématique. Pourtant, cette
démarche ouvre la voie à une appropriation intelligente des formes
existantes et, surtout, à la création de SDF personnalisées.</p>
<p>Nous étudierons deux exemples illustrant la construction mathématique
d’une SDF. Le premier exemple consistera en une exploration de l’espace
bidimensionnel à travers la représentation d’un simple carré. Dans le
second exemple, nous nous pencherons sur la création d’un tore
(<em>torus</em> en anglais), en partant cette fois-ci d’un espace
tridimensionnel. En comprenant la logique et les principes mathématiques
derrière la création de ces SDF, nous serons en mesure non seulement
d’adapter efficacement les formes déjà existantes, mais également de
développer nos propres fonctions SDF, ouvrant ainsi de nouvelles
possibilités créatives.</p>
<h3 class="unnumbered" id="sdf-dun-carré">SDF d’un carré</h3>
<p>Nous commençons par examiner un carré en 2D centré à l’origine. Pour
simplifier le calcul et tirer parti de la symétrie, nous nous
concentrons initialement sur un seul quadrant<a href="#fn9"
class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> de
la forme. Calculer la distance d’un point situé en dessous du troisième
quadrant, équivaut à calculer la distance du point symétrique par
rapport à l’origine, qui se trouverait au-dessus du troisième quadrant
(voir <a href="#box00" data-reference-type="ref"
data-reference="box00">[box00]</a>). Nous définissons <span
class="math inline">\(R_x\)</span> et <span
class="math inline">\(R_y\)</span> comme étant respectivement la largeur
et la hauteur du premier quadrant.</p>
<p>En se référant au premier quadrant, nous pouvons distinguer les
différents cas qui se présentent. En généralisant la solution à l’aide
de la fonction , nous prenons en compte la symétrie. L’espace peut être
divisé en trois parties distinctes : une partie juste au-dessus du
quadrant, une partie juste à droite du quadrant et une troisième partie
« en haut à droite » du quadrant (voir <a href="#box01"
data-reference-type="ref" data-reference="box01">[box01]</a>).</p>
<figure id="box02">
<img src="images//shaders/box00.png" style="height:1.5in" />
<img src="images//shaders/box01.png" style="height:1.5in" />
<img src="images//shaders/box02.png" style="height:1.5in" />
<figcaption>Distance du point P dans la troisième zone</figcaption>
</figure>
<p>Dans la première zone, le calcul est relativement simple : il s’agit
de la distance de la composante <span class="math inline">\(x\)</span>
du point par rapport au côté droit du carré, ce qui se traduit par <span
class="math inline">\(d = P_x - R_x\)</span>. Pour la deuxième zone, la
logique est similaire, mais appliquée verticalement, conduisant à <span
class="math inline">\(d = P_y - R_y\)</span>. Cependant, pour la
troisième zone, nous devons faire appel au théorème de Pythagore<a
href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a> pour calculer la distance entre le
point et le coin supérieur droit du quadrant (voir <a href="#box02"
data-reference-type="ref" data-reference="box02">1.13</a>). Ainsi, nous
obtenons:</p>
<p><span class="math display">\[\begin{aligned}
d = \sqrt{(P_x-R_x)^2 + (P_y-R_y)^2}
\end{aligned}\]</span></p>
<p>Notre objectif est de combiner ces trois expressions mathématiques
pour exprimer la distance <span class="math inline">\(d\)</span> en une
seule. Nous remarquons que les deux premières expressions apparaissent
dans la troisième. En gardant uniquement la troisième expression, nous
aimerions que la composante <span class="math inline">\(y\)</span>
s’annule si nous sommes dans la première zone, et que la composante
<span class="math inline">\(x\)</span> s’annule si nous sommes dans la
deuxième zone. Nous remarquons que dans chaque cas, la composante que
nous aimerions annuler est négative. En utilisant la fonction , nous
pouvons distinguer chaque cas. Finalement, nous concluons que:</p>
<p><span class="math display">\[\begin{aligned}
d = \sqrt{max(P_x-R_x,0)^2 + max(P_y-R_y,0)^2}
\end{aligned}\]</span> Avec la notation vectorielle, nous pouvons
simplifier l’écriture en écrivant: <span
class="math display">\[\begin{aligned}
d = length(max(abs(P)-R, 0))
\end{aligned}\]</span></p>
<p>Une traduction en code GLSL donnerait alors:</p>
<div class="sourceCode" id="cb8" data-language="GLSL"
data-caption="SDF d&#39;un carré" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// p: position du point, s: size du carre</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">box</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">vec2</span> s<span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> m <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>p<span class="op">-</span>s<span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.</span><span class="op">));</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span>m<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 class="unnumbered" id="sdf-dun-tore">SDF d’un tore</h3>
<p>Pour le tore (<em>torus</em> en anglais), nous aborderons les détails
mathématiques de manière concise, mais la méthode de raisonnement reste
la même que celle exposée précédemment. Si nous imaginons le tore
positionné à l’origine, nous pouvons le décrire à l’aide de deux cercles
ou de deux rayons d’un cercle. Tout d’abord, il y a le cercle plus grand
situé dans le plan <span class="math inline">\(XZ\)</span> (le plan
horizontal), puis il y a un cercle plus petit qui tourne autour de ce
premier cercle (voir <a href="#tore01" data-reference-type="ref"
data-reference="tore01">1.14</a>).</p>
<figure id="tore01">
<img src="images//sdf/tore01.png" style="width:50.0%" />
<figcaption>Représentation d’un tore dans l’espace</figcaption>
</figure>
<p>Lorsque nous cherchons à déterminer la distance qui sépare un point
<span class="math inline">\(P\)</span> situé au-dessus du plan <span
class="math inline">\(XZ\)</span> à la surface de ce tore, nous devons
d’abord calculer la distance <span class="math inline">\(d\)</span>
résultant des composantes <span class="math inline">\(x\)</span> et
<span class="math inline">\(y\)</span> du vecteur <span
class="math inline">\(\vec{PC}\)</span> (cela revient à calculer la
norme du vecteur <span class="math inline">\(\vec{PC}\)</span>). L’image
projetée de <span class="math inline">\(P\)</span> sur le plan <span
class="math inline">\(XZ\)</span> nous fournit la valeur de <span
class="math inline">\(x\)</span>. Nous pouvons l’obtenir en soustrayant
le rayon du cercle plus grand de la distance totale de <span
class="math inline">\(P\)</span> à l’origine. La valeur <span
class="math inline">\(y\)</span> correspond simplement à la position
verticale de <span class="math inline">\(P\)</span>.</p>
<div class="sourceCode" id="cb9" data-language="GLSL"
data-caption="SDF d&#39;un tore" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// p: position du point, r: rayon du grand et du petit cercle</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">torus</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec2</span> r<span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">.</span><span class="fu">xz</span><span class="op">)-</span>r<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>x<span class="op">,</span>p<span class="op">.</span><span class="fu">y</span><span class="op">)-</span>r<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Avec ces valeurs de <span class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span>, nous pouvons former un vecteur. Sa
longueur correspond à la distance <span
class="math inline">\(d\)</span>. En soustrayant le rayon du cercle plus
petit de cette longueur, nous obtenons la distance finale à la surface
du tore. En combinant cette fonction de distance signée avec la méthode
permettant de passer aux coordonnées polaires (que nous verrons par la
suite), nous pouvons obtenir des représentations intéressantes où les
repères uv tournent autour de la forme sur les deux axes (voir <a
href="#tore03" data-reference-type="ref"
data-reference="tore03">[tore03]</a> et <a href="#tore05"
data-reference-type="ref" data-reference="tore05">1.15</a>).</p>
<figure id="tore05">
<img src="images//sdf/tore03.png" style="height:1.5in" />
<img src="images//sdf/tore05.png" style="height:1.5in" />
<figcaption>uv autour de l’axe <span
class="math inline">\(X\)</span></figcaption>
</figure>
<h2 id="le-fonctionnement-du-ray-marching">Le fonctionnement du <em>ray
marching</em></h2>
<p>Au début de mon apprentissage des <em>shaders</em>, je parvenais à
décortiquer le fonctionnement de certains <em>shaders</em> 2D mais je me
sentais incapable de comprendre la « magie » qui se cachait derrière les
<em>shaders</em> 3D. Or une grande proportion des <em>shaders</em> 3D
visibles sur Shadertoy sont basés sur l’algorithme du <em><em>ray
marching</em></em>. Il est donc indispensable de décomposer la logique
qui se cache derrière avant d’aborder les techniques plus avancées qui
en découlent.</p>
<p>Bien que d’autres algorithmes plus chers en calculs comme le <em>ray
tracing</em> ou le <em>path tracing</em> permettent de représenter une
scène 3D sur un écran 2D nous nous intéresserons surtout ici au <em>ray
marching</em> qui est très populaire dans le monde de la
<em>demoscene</em>. Le <em>ray marching</em> est utilisé pour dessiner
des scènes 3D sur un écran 2D à l’aide de rayons.</p>
<p>Dans notre monde réel, les sources de lumière telles que le soleil
projettent des rayons lumineux sous forme de photons dans des millions
de directions différentes. Lorsqu’un photon touche un objet, l’énergie
est absorbée par le réseau cristallin d’atomes de l’objet et un autre
photon est libéré. En fonction de la structure cristalline du réseau
atomique du matériau, les photons peuvent être émis dans une direction
aléatoire (réflection diffuse) ou sous le même angle avec lequel ils ont
pénétré le matériau (réflection spéculaire ou miroir).</p>
<p>Avec un ordinateur, si nous essayons de modéliser une scène en 3D en
simulant les rayons d’une source de lumière et en dessinant les objets
visibles depuis le point de vue de la caméra, nous gaspillons des
ressources informatiques. En effet, cette simulation « vers l’avant »
fait en sorte qu’un grand nombre de ces rayons n’atteignent jamais la
caméra. Le <em>ray marching</em> est une simulation « à l’envers » où
les rayons sont tirés à partir d’une caméra. Nous travaillons donc à
l’envers ! Notre caméra émet des rayons dans des directions différentes
(un rayon par <em>pixel</em>). Il faut donc s’imaginer le <em>ray
marching</em> comme une multitude de rayons émanant de notre œil (le
point de vue du spectateur), chaque rayon étant dirigé vers un
<em>pixel</em> spécifique de l’écran (voir <a href="#raymarching00"
data-reference-type="ref"
data-reference="raymarching00">[raymarching00]</a>).</p>
<p>C’est alors que la boucle de <em>ray marching</em> se met en route.
Au départ notre point se situe au niveau de la caméra. Notre scène étant
décrite grâce aux fonctions de distance signée<a href="#fn11"
class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
expliquées précédemment, nous sommes à même de calculer la distance qui
nous sépare de l’objet le plus proche. Cette distance est représentée
par les cercles verts dans la figure ci-dessous (voir <a
href="#raymarching01" data-reference-type="ref"
data-reference="raymarching01">1.16</a>).</p>
<figure id="raymarching01">
<img src="images//raymarching/raymarching00.png" />
<img src="images//raymarching/raymarching01.png" />
<figcaption><em>Ray marching</em> en vue de côté</figcaption>
</figure>
<p>Si cette valeur est très petite on considère que l’on a touché
l’objet et on peut sortir de la boucle. On peut le signaler en changeant
la couleur du <em>pixel</em>. Par contre, si la distance est élevée cela
signifie que nous ne sommes pas à la surface d’un objet, c’est alors que
l’on fait avancer le point selon un vecteur normalisé<a href="#fn12"
class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>
représentant la direction du rayon car l’on est certain de ne pas
rencontrer d’objet. On continue le processus soit jusqu’à rencontrer un
objet soit jusqu’à dépasser une distance définie par le développeur: si
au bout de <span class="math inline">\(128\)</span> boucles de <em>ray
marching</em> le rayon n’a touché aucun objet on considère qu’il touche
le « ciel » et on rend une couleur d’arrière-plan.</p>
<p>Voici à quoi ressemble la fonction de <em>ray marching</em> dans un
contexte GLSL, avec une simple sphère comme seul objet de notre
scène.</p>
<div class="sourceCode" id="cb10" data-language="GLSL"
data-caption="Ray marching" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> r <span class="op">)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">)</span> <span class="op">-</span> r<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">rayMarch</span><span class="op">(</span><span class="dt">vec3</span> ro<span class="op">,</span> <span class="dt">vec3</span> rd<span class="op">,</span> <span class="dt">float</span> start<span class="op">,</span> <span class="dt">float</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> depth <span class="op">=</span> start<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">255</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> p <span class="op">=</span> ro <span class="op">+</span> depth <span class="op">*</span> rd<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="fl">1.</span><span class="op">);</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    depth <span class="op">+=</span> d<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.001</span> <span class="op">||</span> depth <span class="op">&gt;</span> end<span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">return</span> depth<span class="op">;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec2</span> uv <span class="op">=</span> <span class="op">(</span>fragCoord<span class="fl">-.5</span><span class="op">*</span>iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">)/</span>iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> col <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> ro <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span> <span class="co">// ray origin that represents camera position</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> rd <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>uv<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span> <span class="co">// ray direction</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> d <span class="op">=</span> <span class="fu">rayMarch</span><span class="op">(</span>ro<span class="op">,</span> rd<span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">100.</span><span class="op">);</span> <span class="co">// distance to sphere</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="op">(</span>d <span class="op">&gt;</span> <span class="fl">100.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.6</span><span class="op">);</span> <span class="co">// ray didn&#39;t hit anything</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// ray hit something</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Output to screen</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>  fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>col<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="repère-main-gauche-vs.-repère-main-droite">Repère « main
gauche » <em>VS.</em> repère « main droite »</h2>
<p>Avant d’aborder les normales, je vais brièvement discuter des
différents systèmes de coordonnées utilisés pour se repérer dans
l’espace.</p>
<p>Dans les logiciels de modélisation 3D ou les moteurs de jeu, on
entend souvent parler des termes de « main gauche » et « main droite ».
La « main gauche » fait référence à un système de coordonnées où l’axe
des <span class="math inline">\(X\)</span> pointe vers la droite, l’axe
des <span class="math inline">\(Y\)</span> pointe vers le haut, et l’axe
des <span class="math inline">\(Z\)</span> pointe « vers l’intérieur de
l’écran ». C’est le système utilisé dans Unity. La « main droite » est
un système de coordonnées où l’axe des <span
class="math inline">\(X\)</span> pointe vers la droite, l’axe des <span
class="math inline">\(Y\)</span> pointe vers le haut, et l’axe des <span
class="math inline">\(Z\)</span> pointe « vers l’extérieur de l’écran »,
c’est-à-dire « vers nous ». C’est le système utilisé dans Blender. Il
existe également une différenciation en ce qui concerne la
représentation de l’axe vertical par <span
class="math inline">\(Y\)</span> ou <span
class="math inline">\(Z\)</span>. Comme le montre l’image ci-dessous
(voir <a href="#lr_handed" data-reference-type="ref"
data-reference="lr_handed">1.17</a>), il existe au total quatre
configurations possibles.</p>
<p>Ce qui est amusant de noter, c’est qu’Unreal se retrouve seul dans sa
catégorie. Je n’ai pas pu le vérifier, mais la légende raconte que cela
est dû au fait que l’ingénieur en charge de la mise en place du système
de coordonnées pour Unreal était totalement étranger au monde de la 3D,
et a donc choisi ce système de coordonnées au hasard, sans se référer à
ce qui existait déjà.</p>
<figure id="lr_handed">
<div class="center">
<img src="images/shaders/lr_handed.png" style="width:10cm" />
</div>
<figcaption>Systèmes « main gauche » / « main droite » dans les
logiciels 3D</figcaption>
</figure>
<h2 id="calcul-de-la-normale">Calcul de la normale</h2>
<p>Maintenant que nous avons mis en place l’algorithme de <em>ray
marching</em> qui nous permet de savoir si on a touché ou non un objet,
nous devons nous intéresser à la normale à la surface en ce point. Tous
les calculs d’éclairage que nous verrons par la suite se baseront sur
cette normale.</p>
<h3 class="unnumbered" id="dans-le-geometry-shader">Dans le <em>geometry
shader</em></h3>
<p>Si nous étions dans le contexte d’un <em>pipeline</em> graphique «
standard » avec une modélisation en entrée, le calcul de normales
s’effectuerait aisément dans le <em>geometry shader</em>. Comme le
<em>geometry shader</em> reçoit en entrée des primitives sous forme de
triangles (des paquets de trois sommets), il est très facile d’obtenir
la normale avec le produit vectoriel entre deux côtés adjacents du
triangle (voir <a href="#norm00" data-reference-type="ref"
data-reference="norm00">[norm00]</a>).</p>
<p>Supposons un triangle <span class="math inline">\(ABC\)</span>, on
peut déterminer les vecteurs adjacents <span
class="math inline">\(\vec{AB}\)</span> et <span
class="math inline">\(\vec{AC}\)</span> en faisant la différence entre
la position des deux sommets de chaque vecteur.</p>
<p><span class="math display">\[\begin{aligned}
\vec{AB} = B - A \\
\vec{AC} = C - A
\end{aligned}\]</span></p>
<figure id="norm01">
<img src="images/shaders/norm00.png" />
<img src="images/shaders/norm01.png" />
<figcaption>Le <em>geometry shader</em> dans le
<em>pipeline</em></figcaption>
</figure>
<p>Si maintenant on effectue le produit vectoriel<a href="#fn13"
class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>
entre ces deux vecteurs nous obtenons la normale au triangle (voir <a
href="#crossprod00" data-reference-type="ref"
data-reference="crossprod00">[crossprod00]</a>).</p>
<p><span class="math display">\[\begin{aligned}
\vec{N} = \vec{AB} \times \vec{AC}
\end{aligned}\]</span></p>
<figure id="crossprod01">
<img src="images//shaders/crossprod00.png" />
<img src="images//shaders/crossprod01.png" />
<figcaption>Calcul de la normale d’un plan à partir de deux
axes</figcaption>
</figure>
<p>Ensuite, comme d’habitude on normalise le vecteur en divisant chaque
composante par la norme<a href="#fn14" class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a> du vecteur car seule sa direction
nous intéresse. On obtient une normale unitaire.</p>
<p><span class="math display">\[\begin{aligned}
\vec{N}_{unitaire} = \frac{\vec{N}}{\|N\|}
\end{aligned}\]</span></p>
<figure id="norm02">
<div class="center">
<img src="images/shaders/norm02.png" style="width:10cm" />
</div>
<figcaption>Création de sommets à partir d’une sphère dans le
<em>node</em> <em>geometry shader</em> de TouchDesigner</figcaption>
</figure>
<h3 class="unnumbered" id="dans-le-fragment-shader">Dans le <em>fragment
shader</em></h3>
<p>Cependant dans un contexte de <em>livecoding</em> cette méthode ne
peut pas fonctionner puisque nous n’avons pas de <em>mesh</em> en
entrée, la scène étant décrite non pas par une collection de triangles
mais par des SDF.</p>
<p>Pour calculer la normale à la surface nous devons utiliser le
gradient<a href="#fn15" class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a> pour chaque point de la surface. Ce
calcul s’effectue pendant le <em>ray marching</em> au moment où le rayon
atteint l’objet. Ce concept de gradient me semblait assez flou lors de
mes débuts, mais finalement si l’on se réfère au monde en deux
dimensions tout devient plus limpide. Trouver le gradient en un point
équivaut à trouver la pente d’une courbe 2D comme nous savons le faire
avec les dérivées (voir <a href="#grad01" data-reference-type="ref"
data-reference="grad01">1.21</a>).</p>
<p>Dans un graphe à deux dimensions, si voulons calculer la pente d’un
point situé sur une courbe, il nous suffit de calculer la pente de la
droite passant par deux points situés de part et d’autre du point
originel à une distance infiniment petite. Si on ramène cela à un espace
en trois dimensions, ce n’est plus la pente d’une courbe que l’on
cherche à évaluer mais la « pente » d’une surface.</p>
<p>Ainsi pour calculer la normale nous avons besoin de deux points: un
point à l’extérieur du volume de la forme et un autre à l’intérieur, les
deux devant se situer à une distance infinitésimale de la surface. Cette
grandeur infinitésimale est souvent notée <span
class="math inline">\(\epsilon\)</span> (<em>epsilon</em>) en
mathématiques. En GLSL, nous allons donc créer une fonction appelée qui
prend en paramètre un point de contact avec la surface obtenu par la
fonction . Pour chaque composante (ou pour chaque axe) on calcule la
différence entre deux points situés très proches de la surface (un à
l’intérieur et un autre à l’extérieur). Et comme le résultat attendu est
une direction on le normalise.</p>
<div class="sourceCode" id="cb11" data-language="GLSL"
data-caption="Calcul de la normale" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">calcNormal</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> e <span class="op">=</span> <span class="fl">0.0005</span><span class="op">;</span> <span class="co">// epsilon</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.</span><span class="op">;</span> <span class="co">// rayon de la sphere</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">return</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> e<span class="op">,</span> p<span class="op">.</span><span class="fu">y</span><span class="op">,</span> p<span class="op">.</span><span class="fu">z</span><span class="op">),</span> r<span class="op">)</span> <span class="op">-</span> <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> e<span class="op">,</span> p<span class="op">.</span><span class="fu">y</span><span class="op">,</span> p<span class="op">.</span><span class="fu">z</span><span class="op">),</span> r<span class="op">),</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> e<span class="op">,</span> p<span class="op">.</span><span class="fu">z</span><span class="op">),</span> r<span class="op">)</span> <span class="op">-</span> <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> e<span class="op">,</span> p<span class="op">.</span><span class="fu">z</span><span class="op">),</span> r<span class="op">),</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">y</span><span class="op">,</span> p<span class="op">.</span><span class="fu">z</span> <span class="op">+</span> e<span class="op">),</span> r<span class="op">)</span> <span class="op">-</span> <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">y</span><span class="op">,</span> p<span class="op">.</span><span class="fu">z</span> <span class="op">-</span> e<span class="op">),</span> r<span class="op">)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">));</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Il est important de comprendre que la fonction renvoie une direction
de rayon qui représente la direction vers laquelle un point de la sphère
est orienté. C’est grâce à ce vecteur que nous pourrons implémenter les
fonctions qui se chargeront du calcul de la lumière (voir <a
href="#meduse_02" data-reference-type="ref"
data-reference="meduse_02">[meduse_02]</a>).</p>
<figure id="grad01">
<img src="images/shaders/shaderatelier_08.jpg" />
<img src="images/shaders/grad01.png" />
<figcaption>Gradient en 2D</figcaption>
</figure>
<h2 id="modèles-déclairage">Modèles d’éclairage</h2>
<p>Maintenant que nous avons accès à la normale pour chaque point de la
surface de nos objets nous pouvons commencer à réfléchir à leur rendu.
En d’autres termes c’est bien le <em>fragment shader</em> qui sera
responsable du calcul de la lumière.</p>
<p>Pour simuler l’éclairage (le <em>lighting</em> en anglais) du monde
réel sur nos ordinateurs on se base sur des modèles qui sont une
approximation de la physique de la lumière telle que nous la
connaissons. L’un de ces modèles est appelé le modèle d’éclairage Phong
et ses principales composantes sont au nombre de trois: l’éclairage
ambiant, l’éclairage diffus et l’éclairage spéculaire (voir <a
href="#phong00" data-reference-type="ref"
data-reference="phong00">1.22</a>).</p>
<figure id="phong00">
<img src="images//shaders/phong00.png" style="width:90.0%" />
<figcaption>Modèle d’éclairage Phong</figcaption>
</figure>
<h2 id="les-trois-composantes-du-modèle-de-phong">Les trois composantes
du modèle de Phong</h2>
<p>L’éclairage ambiant est celui que l’on observe dans un lieu sombre.
Si notre environnement est obscur nous parvenons tout de même à
distinguer des formes dans le noir car il existe quelque part une faible
source lumineuse qui éclaire (la lune par exemple).</p>
<p>L’éclairage diffus quant à lui simule l’impact directionnel d’une
source lumineuse sur un objet. C’est celle que l’on observe le plus dans
la vie de tous les jours (un mur éclairé par exemple). Ce que l’on
remarque avec cette composante, c’est que plus une partie d’un objet est
orientée vers la source de lumière, plus elle devient lumineuse. Pour
s’en convaincre, on peut jouer avec l’inclinaison d’une lampe torche
dirigée vers un mur.</p>
<p>Enfin, l’éclairage spéculaire simule le point lumineux d’une lumière
qui apparaît sur les objets brillants. Un exemple caractéristique est
celui de la tâche brillante qui apparaît sur la carrosserie des voitures
en plein soleil.</p>
<p>Tout l’art de l’éclairage consiste à simuler ces trois composantes
pour créer des scènes intéressantes.</p>
<h3 class="unnumbered"
id="les-trois-composantes-du-modèle-de-phong-en-code">Les trois
composantes du modèle de Phong en code</h3>
<h4 class="unnumbered" id="lumière-ambiante">Lumière ambiante</h4>
<p>Pour appliquer la composante de lumière ambiante en GLSL il nous
suffit de rajouter une constante d’éclairage qui donnera toujours une
couleur à l’objet (voir <a href="#ambiant00" data-reference-type="ref"
data-reference="ambiant00">1.23</a>). Nous prenons la couleur de la
lumière, nous la multiplions avec un petit facteur ambiant constant,
puis nous la multiplions avec la couleur de l’objet et enfin nous
l’utilisons comme couleur du fragment dans le <em>shader</em> de
l’objet. Nous n’avons pas besoin de modéliser la source lumineuse car
l’ajout de l’éclairage ambiant en code est entièrement artificiel.</p>
<div class="sourceCode" id="cb12" data-language="GLSL"
data-caption="Lumière ambiante" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> ambientStrength <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> ambient <span class="op">=</span> ambientStrength <span class="op">*</span> lightColor<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> result <span class="op">=</span> ambient <span class="op">*</span> objectColor<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>FragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>result<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div>
<h4 class="unnumbered" id="lumière-diffuse">Lumière diffuse</h4>
<p>Pour l’éclairage diffus, nous aurons besoin d’outils mathématiques
mais aussi d’une représentation de la lumière. Cette dernière peut être
définie par une position dans l’espace 3D. Dans la section consacrée au
calcul de normales nous symbolisions la direction par un vecteur avec
trois composantes mais rien ne nous empêche d’utiliser cette même
structure pour traduire la position de la source lumineuse.</p>
<div class="sourceCode" id="cb13" data-language="GLSL"
data-caption="Position de la lumière avec un 
\custominline{vec3}" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> lightPosition <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span></code></pre></div>
<p>Ici on considère une source de lumière positionnelle comme une
ampoule, c’est à dire que chaque point de la surface de nos objets
recevra un rayon lumineux différent (tous les rayons ont une direction
différente selon le point de la surface, voir <a href="#diffuse00"
data-reference-type="ref"
data-reference="diffuse00">[diffuse00]</a>).</p>
<figure id="ambiant00">
<img src="images/shaders/diffuse00.png" />
<img src="images/shaders/ambiant00.png" />
<figcaption>Représentation de la lumière ambiante</figcaption>
</figure>
<p>Pour représenter cette direction du rayon lumineux qui diffère pour
chaque point de la surface de l’objet nous devons calculer le vecteur
représentant la direction du rayon lumineux. Le calcul est assez simple,
la direction du rayon lumineux sera la différence entre la position de
la lumière et le point que nous obtenons en retour de la boucle de
<em>ray marching</em>. Il ne faut pas oublier de normaliser le résultat
car seule la direction nous importe.</p>
<div class="sourceCode" id="cb14" data-language="GLSL"
data-caption="Direction de la lumière" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> lightDirection <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lightPosition <span class="op">-</span> p<span class="op">);</span></span></code></pre></div>
<p>Pour connaître la quantité de lumière qui frappe la surface de notre
objet, nous devons utiliser le produit scalaire<a href="#fn16"
class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>
entre le rayon lumineux et la normale. Le produit scalaire se révèle
souvent très pratique car il permet de connaître le degré de
colinéarité<a href="#fn17" class="footnote-ref" id="fnref17"
role="doc-noteref"><sup>17</sup></a> de deux vecteurs. Si les deux
vecteurs ont la même direction, le résultat du produit scalaire sera
<span class="math inline">\(1\)</span>. S’ils ont des directions
opposées il renverra <span class="math inline">\(-1\)</span>. S’ils sont
orthogonaux<a href="#fn18" class="footnote-ref" id="fnref18"
role="doc-noteref"><sup>18</sup></a> le résultat sera nul. Enfin, dans
tous les autres cas le produit scalaire retournera une valeur comprise
entre <span class="math inline">\(-1\)</span> et <span
class="math inline">\(1\)</span> qui correspondra au degré de
colinéarité des deux vecteurs.</p>
<p>Le produit scalaire renvoie donc un scalaire que nous pouvons
utiliser pour calculer l’impact de la lumière sur la couleur du
fragment, ce qui donne des fragments éclairés différemment en fonction
de leur orientation par rapport à la lumière.</p>
<p>En GLSL, nous utilisons la fonction pour calculer cette valeur.</p>
<div class="sourceCode" id="cb15" data-language="GLSL"
data-caption="Quantité de lumière diffuse" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dif <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDirection<span class="op">);</span> <span class="co">// dif = diffuse reflection</span></span></code></pre></div>
<p>Lorsque nous effectuons le produit scalaire entre les vecteurs de la
normale et de la direction de la lumière, il se peut que nous obtenions
une valeur négative car renvoie des valeurs entre <span
class="math inline">\(-1\)</span> et <span
class="math inline">\(+1\)</span>. Pour maintenir la valeur entre <span
class="math inline">\(0\)</span> et <span
class="math inline">\(1\)</span> afin d’obtenir une plage de valeurs
plus correcte, nous pouvons utiliser la fonction .</p>
<div class="sourceCode" id="cb16" data-language="GLSL"
data-caption="\custominline{clamp()} sur diffuse" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dif <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDirection<span class="op">),</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">);</span></span></code></pre></div>
<p>Maintenant si on veut rajouter un peu de couleur à notre objet il
suffit de multiplier la valeur de la réflection diffuse par un vecteur
de couleur qui simulera la couleur du matériau:</p>
<div class="sourceCode" id="cb17" data-language="GLSL"
data-caption="Couleur diffuse" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>col <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>dif<span class="op">)</span> <span class="op">*</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="fl">0.58</span><span class="op">,</span> <span class="fl">0.29</span><span class="op">);</span></span></code></pre></div>
<h4 class="unnumbered" id="lumière-spéculaire">Lumière spéculaire</h4>
<p>La dernière composante de lumière à implémenter est l’éclairage
spéculaire. Dans la réalité, les matériaux tels que les métaux et les
surfaces polies présentent une réflexion spéculaire qui semble plus
brillante en fonction de l’angle de la caméra ou de l’endroit où le
spectateur fait face à l’objet. Comme l’éclairage diffus, l’éclairage
spéculaire est basé sur le vecteur de direction de la lumière et les
vecteurs de normales de l’objet, mais cette fois il est également basé
sur la direction de la vue, c’est-à-dire la direction à partir de
laquelle l’observateur regarde le fragment.</p>
<p>Comme l’éclairage spéculaire est basé sur les propriétés
réfléchissantes des surfaces, si nous considérons la surface de l’objet
comme un miroir, l’éclairage spéculaire est le plus fort là où nous
voyons la lumière se refléter sur la surface (voir <a href="#specular00"
data-reference-type="ref" data-reference="specular00">[specular00]</a>).
Sur le schéma, plus l’angle formé par le vecteur <span
class="math inline">\(\vec{R}\)</span> et le vecteur de vue (en gris)
est petit plus l’impact de la lumière spéculaire sera important.</p>
<figure id="specular01">
<img src="images/shaders/specular00.png" />
<img src="images/shaders/specular01.png" />
<figcaption>Éclairage spéculaire</figcaption>
</figure>
<p>Nous avons vu précédemment comment mesurer un angle entre deux
vecteurs avec la fonction . Avec la fonction intégrée<a href="#fn19"
class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>
nous pouvons calculer la direction du rayon réfléchi à partir du rayon
incident. Cette fonction prend deux paramètres : le vecteur de direction
du rayon incident et le vecteur normal.</p>
<p>Nous avons déjà calculé le vecteur de direction de la lumière pour le
calcul de la lumière diffuse. La seule variable supplémentaire dont nous
avons besoin pour calculer l’éclairage spéculaire est le vecteur de vue.
Mais celui-ci est assez simple à calculer, c’est le vecteur qui part du
point d’origine de notre <em>ray marching</em> et qui se dirige vers le
point de notre surface.</p>
<p>Dans le code GLSL, la valeur <span
class="math inline">\(k\_s\)</span> est la constante de réflexion
spéculaire qui influera sur l’étalement de la tâche brillante, la valeur
<span class="math inline">\(i\_s\)</span> représente la couleur de la
spéculaire, ici un blanc pur.</p>
<div class="sourceCode" id="cb18" data-language="GLSL"
data-caption="Spéculaire" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">mat3</span> <span class="fu">camera</span><span class="op">(</span><span class="dt">vec3</span> cameraPos<span class="op">,</span> <span class="dt">vec3</span> lookAtPoint<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// specular</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> k_s <span class="op">=</span> <span class="fl">0.6</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> dotRV <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span><span class="bu">reflect</span><span class="op">(</span>lightDir<span class="op">,</span> normal<span class="op">),</span> <span class="op">-</span>rd<span class="op">),</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> i_s <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> alpha <span class="op">=</span> <span class="fl">10.</span><span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> specular <span class="op">=</span> k_s <span class="op">*</span> <span class="bu">pow</span><span class="op">(</span>dotRV<span class="op">,</span> alpha<span class="op">)</span> <span class="op">*</span> i_s<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>En conclusion, la spéculaire peut réellement améliorer l’aspect de
notre scène en ajoutant un peu d’éclat ou de brillance à nos objets.</p>
<h3 class="unnumbered" id="code-complet-de-léclairage-de-phong">Code
complet de l’éclairage de Phong</h3>
<div class="sourceCode" id="cb19" data-language="GLSL"
data-caption="Code complet" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> MAX_MARCHING_STEPS <span class="op">=</span> <span class="dv">255</span><span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">float</span> MIN_DIST <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">float</span> MAX_DIST <span class="op">=</span> <span class="fl">100.0</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">float</span> PRECISION <span class="op">=</span> <span class="fl">0.001</span><span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> r <span class="op">)</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> <span class="dt">offset</span> <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">offset</span><span class="op">)</span> <span class="op">-</span> r<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">rayMarch</span><span class="op">(</span><span class="dt">vec3</span> ro<span class="op">,</span> <span class="dt">vec3</span> rd<span class="op">,</span> <span class="dt">float</span> start<span class="op">,</span> <span class="dt">float</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> depth <span class="op">=</span> start<span class="op">;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> MAX_MARCHING_STEPS<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> p <span class="op">=</span> ro <span class="op">+</span> depth <span class="op">*</span> rd<span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="fl">1.</span><span class="op">);</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    depth <span class="op">+=</span> d<span class="op">;</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>d <span class="op">&lt;</span> PRECISION <span class="op">||</span> depth <span class="op">&gt;</span> end<span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">return</span> depth<span class="op">;</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">calcNormal</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> e <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.0005</span><span class="op">;</span> <span class="co">// epsilon</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.</span><span class="op">;</span> <span class="co">// rayon de la sphere</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">normalize</span><span class="op">(</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>      e<span class="op">.</span><span class="fu">xyy</span> <span class="op">*</span> <span class="fu">sdSphere</span><span class="op">(</span>p <span class="op">+</span> e<span class="op">.</span><span class="fu">xyy</span><span class="op">,</span> r<span class="op">)</span> <span class="op">+</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>      e<span class="op">.</span><span class="fu">yyx</span> <span class="op">*</span> <span class="fu">sdSphere</span><span class="op">(</span>p <span class="op">+</span> e<span class="op">.</span><span class="fu">yyx</span><span class="op">,</span> r<span class="op">)</span> <span class="op">+</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>      e<span class="op">.</span><span class="fu">yxy</span> <span class="op">*</span> <span class="fu">sdSphere</span><span class="op">(</span>p <span class="op">+</span> e<span class="op">.</span><span class="fu">yxy</span><span class="op">,</span> r<span class="op">)</span> <span class="op">+</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>      e<span class="op">.</span><span class="fu">xxx</span> <span class="op">*</span> <span class="fu">sdSphere</span><span class="op">(</span>p <span class="op">+</span> e<span class="op">.</span><span class="fu">xxx</span><span class="op">,</span> r<span class="op">));</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span> <span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord <span class="op">)</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec2</span> uv <span class="op">=</span> <span class="op">(</span>fragCoord<span class="fl">-.5</span><span class="op">*</span>iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">)/</span>iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> backgroundColor <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.835</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> col <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> ro <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span> <span class="co">// ray origin qui represente la position de la camera</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> rd <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>uv<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span> <span class="co">// ray direction</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> d <span class="op">=</span> <span class="fu">rayMarch</span><span class="op">(</span>ro<span class="op">,</span> rd<span class="op">,</span> MIN_DIST<span class="op">,</span> MAX_DIST<span class="op">);</span> <span class="co">// distance par rapport a la sphere</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="op">(</span>d <span class="op">&gt;</span> MAX_DIST<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>  col <span class="op">=</span> backgroundColor<span class="op">;</span> <span class="co">// le rayon n a rien touche</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> p <span class="op">=</span> ro <span class="op">+</span> rd <span class="op">*</span> d<span class="op">;</span> <span class="co">// le rayon a touche la sphere au point p</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> normal <span class="op">=</span> <span class="fu">calcNormal</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> lightPosition <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> lightDirection <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lightPosition <span class="op">-</span> p<span class="op">);</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// calculer la diffuse grace au produit scalaire</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// entre la normale et la direction de la lumiere.</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dif <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDirection<span class="op">),</span> <span class="fl">0.3</span><span class="op">,</span> <span class="fl">1.</span><span class="op">);</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ajouter la couleur orange</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// et une couleur pour le background</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> dif <span class="op">*</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="fl">0.58</span><span class="op">,</span> <span class="fl">0.29</span><span class="op">)</span> <span class="op">+</span> backgroundColor <span class="op">*</span> <span class="op">.</span><span class="fu">2</span><span class="op">;</span></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>  <span class="co">// sortie vers l ecran</span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>  fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>col<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="discriminer-les-objets">Discriminer les objets</h2>
<p>Une stratégie particulièrement efficace en <em>livecoding</em>
consiste à pouvoir différencier les objets afin de leur appliquer des
matériaux distincts. Pour ce faire, il est nécessaire de refactoriser le
code, notamment les fonctions décrivant les objets à l’aide des SDF, de
manière à ce qu’elles retournent un identifiant en plus de la
distance.</p>
<div class="sourceCode" id="cb20" data-language="GLSL"
data-caption="SDF avec id" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="dt">float</span> <span class="fu">_cube</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec3</span> s<span class="op">)</span> <span class="co">// s pour size en X,Y,Z</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> l <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">)-</span>s<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">max</span><span class="op">(</span>l<span class="op">.</span><span class="fu">x</span><span class="op">,</span><span class="bu">max</span><span class="op">(</span>l<span class="op">.</span><span class="fu">y</span><span class="op">,</span>l<span class="op">.</span><span class="fu">z</span><span class="op">));</span> <span class="co">// combinaisons d intersection des 3 axes</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>L’autre fonction à redéfinir est la fonctions qui nous permettait de
combiner nos formes. Désormais, comme elle reçoit en paramètre un
contenant la distance et l’identifiant, elle doit comparer les distances
avant de retourner le .</p>
<div class="sourceCode" id="cb21" data-language="GLSL"
data-caption="Nouvelle fonction \custominline{min()}"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">_min</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> b<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="kw">return</span> a<span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> b<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>D’autres parties du code doivent être refactorisées en conséquence,
tel que le calcul de la normale qui dépendait de la fonction de calcul
de distance qui est maintenant modifiée. Le calcul de la normale devient
alors:</p>
<div class="sourceCode" id="cb22" data-language="GLSL"
data-caption="Nouvelle fonction \custominline{getNorm()}"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">getNorm</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> eps <span class="op">=</span> <span class="dt">vec2</span><span class="op">(.</span><span class="fu">01</span><span class="op">,</span><span class="fl">0.</span><span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on rajoute .x pour recuperer la composante qui decrit la distance</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">normalize</span><span class="op">(</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span><span class="op">(</span><span class="fu">map</span><span class="op">(</span>p<span class="op">-</span>eps<span class="op">.</span><span class="fu">xyy</span><span class="op">).</span><span class="fu">x</span><span class="op">,</span><span class="fu">map</span><span class="op">(</span>p<span class="op">-</span>eps<span class="op">.</span><span class="fu">yxy</span><span class="op">).</span><span class="fu">x</span><span class="op">,</span><span class="fu">map</span><span class="op">(</span>p<span class="op">-</span>eps<span class="op">.</span><span class="fu">yyx</span><span class="op">).</span><span class="fu">x</span><span class="op">)</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span><span class="dt">vec3</span><span class="op">(</span><span class="fu">map</span><span class="op">(</span>p<span class="op">+</span>eps<span class="op">.</span><span class="fu">xyy</span><span class="op">).</span><span class="fu">x</span><span class="op">,</span><span class="fu">map</span><span class="op">(</span>p<span class="op">+</span>eps<span class="op">.</span><span class="fu">yxy</span><span class="op">).</span><span class="fu">x</span><span class="op">,</span><span class="fu">map</span><span class="op">(</span>p<span class="op">+</span>eps<span class="op">.</span><span class="fu">yyx</span><span class="op">).</span><span class="fu">x</span><span class="op">)</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Ensuite, lors du rendu, il est possible d’assigner des couleurs à
chaque objet en examinant l’identifiant de l’objet le plus proche
renvoyé par l’algorithme de <em>ray marching</em>. Lorsqu’il est établi
qu’un objet a été touché par le rayon, il est possible de déterminer
lequel en effectuant un test sur son identifiant.</p>
<div class="sourceCode" id="cb23" data-language="GLSL"
data-caption="Discriminer les objets avec l&#39;id dans le  \textit{ray marching}"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span><span class="op">(</span><span class="dt">float</span> i<span class="op">=</span><span class="fl">0.</span><span class="op">;</span> i<span class="op">&lt;</span><span class="fl">128.</span><span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// cartographie la scene, le vec2 contient la distance et l&#39;id des objets de la scene</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> res <span class="op">=</span> <span class="fu">map</span><span class="op">(</span>p<span class="op">);</span> </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// on compare la distance</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>res<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="op">.</span><span class="fu">01</span><span class="op">)</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>            </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// on discrimine les objets</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> <span class="op">(</span>res<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">2.</span><span class="op">)</span> <span class="op">(...);</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> <span class="op">(</span>res<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">1.</span><span class="op">)</span> <span class="op">(...);</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> <span class="op">(</span>res<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">0.</span><span class="op">)</span> <span class="op">(...);</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">break</span><span class="op">;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        p<span class="op">+=</span> rd<span class="op">*</span>res<span class="op">.</span><span class="fu">x</span><span class="op">;</span>  </span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 class="unnumbered" id="problème-valeurs-fractionnaires">Problème
valeurs fractionnaires</h3>
<p>On peut remarquer un détail dans le code : les identifiants des
objets sont représentés par des valeurs fractionnaires (), c’est-à-dire
des nombres à virgule dans le langage courant. Ensuite, nous vérifions
l’identifiant dans la fonction de rendu en examinant si cette valeur
fractionnaire est supérieure à un nombre entier.</p>
<p>Une alternative aurait été d’utiliser des nombres entiers pour
identifier les objets, puis d’utiliser l’opérateur d’égalité pour
déterminer quel objet est touché par le rayon. Cependant, cette méthode,
bien que plus naturelle et intuitive, ne fonctionne pas de manière
fiable avec tous les compilateurs. En effet, le comportement de
l’opérateur peut varier selon les architectures, ce qui peut entraîner
des situations difficiles à déboguer.</p>
<p>La méthode la plus sûre reste l’utilisation de valeurs fractionnaires
et d’une vérification avec l’opérateur « supérieur à » () car cela
garantit un rendu correct de la scène.</p>
<h2 id="dautres-manières-de-discriminer-les-objets">D’autres manières de
discriminer les objets</h2>
<p>Cette méthode de discrimination des objets est extrêmement utile en
<em>livecoding</em>, car elle est intuitive et rapide à mettre en œuvre.
Bien qu’il existe d’autres approches, elles sont souvent plus complexes
à implémenter, et donc peu adaptées à la scène.</p>
<p>Parmi ces techniques, de nombreuses utilisent les structures
inspirées du langage C++ (), qui sont un autre moyen pour organiser le
code en GLSL. Les structures peuvent être imaginées comme une
combinaison de variables pour représenter des concepts. Par exemple, on
peut définir une structure spécifique pour représenter le concept de
surface dans le monde physique :</p>
<div class="sourceCode" id="cb24" data-language="GLSL"
data-caption="Utilisation d&#39;une structure" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Surface <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> signedDistance<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>À la relecture du code, on comprend clairement que la surface possède
deux propriétés: sa distance par rapport à la caméra et une couleur
associée à son matériau. Toute l’astuce ensuite consiste à réadapter son
code (cohérence des valeurs de retour, refactorisation de certaines
fonctions). Une fonction de distance prenant en compte cette nouvelle
structure pourrait être réécrite de la manière suivante :</p>
<div class="sourceCode" id="cb25" data-language="GLSL"
data-caption="Refactorisation d&#39;une SDF" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>Surface <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> r<span class="op">,</span> <span class="dt">vec3</span> <span class="dt">offset</span><span class="op">,</span> <span class="dt">vec3</span> col<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">offset</span><span class="op">)</span> <span class="op">-</span> r<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">return</span> <span class="fu">Surface</span><span class="op">(</span>d<span class="op">,</span> col<span class="op">);</span> <span class="co">// We&#39;re initializing a new &quot;Surface&quot; struct here and then returning it</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Dans un contexte en dehors du <em>livecoding</em>, l’utilisation de
structures semble être le choix le plus judicieux pour améliorer la
lisibilité du code, car elles permettent une organisation claire et
cohérente des données. Les structures rendent le code plus facile à
interpréter et donnent un aspect plus soigné.</p>
<p>Cette approche de conceptualisation du code, similaire à la
programmation orientée objet, pourrait également être appliquée aux
lumières. En effet, chaque lumière pourrait être représentée par une
structure regroupant ses différentes caractéristiques telles que sa
couleur, sa position et son intensité. Cela faciliterait la gestion et
la manipulation des lumières dans le code, rendant ainsi le programme
plus modulaire et plus facile à maintenir.</p>
<h2 id="mise-en-place-dune-caméra">Mise en place d’une caméra</h2>
<p>Maintenant que avons la capacité de dessiner notre scène et de
calculer son éclairage, on pourrait rajouter une caméra pour permettre
de naviguer dans la scène. Cela offrirait davantage de contrôle sur ce
que le spectateur observe, enrichissant ainsi l’expérience visuelle.</p>
<p>Jusqu’à présent, nous avons représenté la caméra comme un simple
point fixe dirigé vers la scène. Cependant, pour créer une caméra plus
flexible, similaire à celles que nous utilisons couramment dans les
logiciels de modélisation 3D tels que Maya (permettant des rotations
autour des objets ou le ciblage de certaines parties de la scène), nous
devons utiliser des concepts mathématiques relativement simples à
assimiler.</p>
<p>Pour intégrer la caméra souhaitée, nous aurions besoin d’une fonction
prenant en paramètre l’origine du rayon et le point à observer qui nous
renverrait une matrice de dimensions <span
class="math inline">\(3\times3\)</span> à multiplier pour obtenir la
nouvelle direction du rayon pour le calcul du <em>ray marching</em>.
Avant d’expliquer les mathématiques qui se cachent derrière, examinons
le code final:</p>
<div class="sourceCode" id="cb26" data-language="GLSL"
data-caption="Fonction \custominline{camera()}" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">mat3</span> <span class="fu">camera</span><span class="op">(</span><span class="dt">vec3</span> cameraPos<span class="op">,</span> <span class="dt">vec3</span> lookAtPoint<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> cd <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lookAtPoint <span class="op">-</span> cameraPos<span class="op">);</span> <span class="co">// camera direction</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> cr <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="bu">cross</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">),</span> cd<span class="op">));</span> <span class="co">// camera right</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> cu <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="bu">cross</span><span class="op">(</span>cd<span class="op">,</span> cr<span class="op">));</span> <span class="co">// camera up</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">mat3</span><span class="op">(-</span>cr<span class="op">,</span> cu<span class="op">,</span> <span class="op">-</span>cd<span class="op">);</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure id="camera00">
<div class="center">
<img src="images/shaders/camera00.png" style="width:75.0%" />
</div>
<figcaption>Intégration d’une caméra</figcaption>
</figure>
<p>L’image <a href="#camera00" data-reference-type="ref"
data-reference="camera00">1.25</a> nous permet de comprendre comment
cette matrice <span class="math inline">\(3\times3\)</span> a été
construite. Nous devons déterminer où la caméra regarde et comment elle
est inclinée en analysant trois vecteurs importants de la caméra : le
vecteur « direction de la caméra » (), le vecteur « droite de la
caméra » () et le vecteur « haut de la caméra » ().</p>
<p>À la première étape, nous recevons simplement l’origine du rayon
comme position de la caméra. La deuxième étape permet de calculer la
direction du rayon. Elle s’obtient en faisant la soustraction entre le
point que l’on vise et la position de la caméra. Encore une fois on
normalise ce vecteur car seule la direction nous importe.</p>
<div class="sourceCode" id="cb27" data-language="GLSL"
data-caption="Direction de la caméra" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> cd <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lookAtPoint <span class="op">-</span> cameraPos<span class="op">);</span> <span class="co">// direction de la camera</span></span></code></pre></div>
<p>Lors de la troisième étape on veut calculer le vecteur « à droite de
la caméra ». Pour cela on utilise le produit vectoriel (<em>cross
product</em> en anglais, en code) entre un vecteur unitaire toujours
dirigé vers le haut () et le vecteur de direction obtenu à l’étape
précédente:</p>
<div class="sourceCode" id="cb28" data-language="GLSL"
data-caption="Vecteur « à droite de la caméra »"
data-captionpos="b"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> cd <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lookAtPoint <span class="op">-</span> cameraPos<span class="op">);</span> <span class="co">// direction de la camera</span></span></code></pre></div>
<p>Enfin à la dernière étape, toujours avec le produit vectoriel nous
obtenons le vecteur « caméra vers le haut » grâce aux vecteurs « caméra
vers la droite » et « direction des rayons ».</p>
<div class="sourceCode" id="cb29" data-language="GLSL"
data-caption="Vecteur « caméra vers le haut »" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> cu <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="bu">cross</span><span class="op">(</span>cd<span class="op">,</span> cr<span class="op">));</span> <span class="co">// camera up</span></span></code></pre></div>
<p>Nous pouvons alors créer une matrice de transformation <span
class="math inline">\(3\times3\)</span> en combinant tous ces vecteurs
nouvellement calculés.</p>
<div class="sourceCode" id="cb30" data-language="GLSL"
data-caption="Matrice $3\times3$ pour la caméra" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> <span class="dt">mat3</span><span class="op">(-</span>cr<span class="op">,</span> cu<span class="op">,</span> <span class="op">-</span>cd<span class="op">);</span></span></code></pre></div>
<p>Le signe négatif devant et est une convention simple qui indique le
sens de la direction le long de chaque axe. En pratique, il suffit
désormais de spécifier un point d’observation et un point d’origine,
puis de les passer à notre fonction . Cela nous permettra d’obtenir le
nouveau rayon de direction, à partir duquel nous pouvons ensuite
démarrer l’algorithme de <em>ray marching</em>.</p>
<div class="sourceCode" id="cb31" data-language="GLSL"
data-caption="Transformation du rayon" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> lp <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// le point qu&#39;on observe</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> ro <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span> <span class="co">// la position de la camera</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> rd <span class="op">=</span> <span class="fu">camera</span><span class="op">(</span>ro<span class="op">,</span> lp<span class="op">)</span> <span class="op">*</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>uv<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span> <span class="co">// le nouveau rayon de direction</span></span></code></pre></div>
<p>Nous obtenons ainsi une caméra bien plus flexible, capable d’ajuster
la direction des rayons en fonction de sa position et/ou du point
qu’elle observe. Par exemple, pour effectuer une rotation autour d’un
objet, il suffit de décrire une trajectoire circulaire de la caméra en
utilisant les coordonnées polaires pour la position d’origine, tout en
maintenant la hauteur constante. Cette rotation peut être réalisée en
modifiant les coordonnées polaires de la position d’origine de la
caméra, et en utilisant les fonctions trigonométriques telles que et
appliquées au temps pour obtenir un mouvement circulaire cyclique et
constant.</p>
<div class="sourceCode" id="cb32" data-language="GLSL"
data-caption="Rotation de la caméra autour d&#39;un objet"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> lp <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="op">-</span><span class="dv">4</span><span class="op">);</span> <span class="co">// point observe</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> ro <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// position de la camera</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co">// on fixe une distance pour la camera</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> cameraRadius <span class="op">=</span> <span class="fl">10.</span><span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">// on modifie la position de la camera en fonction du temps</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>ro<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> cameraRadius <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span>iTime<span class="op">)</span> <span class="op">+</span> lp<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>ro<span class="op">.</span><span class="fu">z</span> <span class="op">=</span> cameraRadius <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime<span class="op">)</span> <span class="op">+</span> lp<span class="op">.</span><span class="fu">z</span><span class="op">;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> rd <span class="op">=</span> <span class="fu">camera</span><span class="op">(</span>ro<span class="op">,</span> lp<span class="op">)</span> <span class="op">*</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>uv<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span> <span class="co">// nouvelle direction de rayon</span></span></code></pre></div>
<h2 id="répétition-de-domaine">Répétition de domaine</h2>
<h3 class="unnumbered" id="introduction-1">Introduction</h3>
<p>Nous avons récemment exploré la représentation d’une scène 3D en
utilisant l’algorithme de <em>ray marching</em> appliqué à nos SDF
décrivant la scène. Avec seulement une vingtaine de lignes de code, il
est possible d’animer et de rendre un objet 3D, sans avoir besoin d’un
moteur de rendu externe.</p>
<p>Auparavant, nous avons également introduit la fonction , qui facilite
la fusion harmonieuse des objets. Nous allons désormais nous pencher sur
la répétition de domaine, une technique qui permet de reproduire un
objet un nombre infini de fois avec une seule ligne de code, évitant
ainsi la nécessité de créer une infrastructure d’instanciation complexe.
Cette section est dédiée à l’exploration approfondie de cette méthode,
en mettant en évidence ses avantages, ses limites et ses
applications.</p>
<figure id="shadat04">
<img src="images/shaders/shaderatelier_02.jpg" />
<img src="images/shaders/shaderatelier_04.jpg" />
<figcaption>Répétition sur deux axes</figcaption>
</figure>
<h3 class="unnumbered" id="définition-répétition-de-domaine">Définition:
répétition de domaine</h3>
<p>La répétition de domaine vise à transformer une SDF, exprimée sous
forme de fonction mathématique, en une forme périodique, la faisant se
répéter continuellement dans l’espace, à l’image d’une fonction . Pour
illustrer, voici une méthode simple pour rendre une SDF périodique dans
la direction <span class="math inline">\(X\)</span> :</p>
<div class="sourceCode" id="cb33" data-language="GLSL"
data-caption="Répétition de l&#39;espace sur l&#39;axe $X$"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">// repetition de l&#39;espace</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">repeated</span><span class="op">(</span> <span class="dt">vec3</span> p <span class="op">)</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> <span class="bu">round</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">sdf</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Dans ce contexte, représente la forme fondamentale que nous
souhaitons répéter. La fonction détermine l’entier le plus proche de
<span class="math inline">\(x\)</span> et l’utilise comme nouveau centre
de coordonnées. Cela établit un nouveau système de coordonnées tous les
<span class="math inline">\(1\)</span> unité de distance, formant ainsi
une mosaïque spatiale dans la direction <span
class="math inline">\(x\)</span>. Autrement dit, cette opération
recentre continuellement le domaine de la fonction, <span
class="math inline">\(p\)</span>, dans l’intervalle <span
class="math inline">\((-0.5, 0.5)\)</span>. Si la SDF (représentée par
une boîte arrondie dans les images <a href="#repet00"
data-reference-type="ref" data-reference="repet00">[repet00]</a> et <a
href="#repet01" data-reference-type="ref"
data-reference="repet01">1.27</a>) est définie dans cet intervalle, elle
adoptera un comportement périodique.</p>
<figure id="repet01">
<img src="images/sdf/repet00.png" />
<img src="images/sdf/repet01.png" />
<figcaption>Répétition de domaine en <span
class="math inline">\(X\)</span> et en <span
class="math inline">\(Y\)</span></figcaption>
</figure>
<p>Il est possible d’améliorer la méthode en offrant la possibilité de
contrôler l’espacement entre les répétitions, correspondant à la période
de la fonction. Cette personnalisation s’effectue en ajustant l’échelle
du domaine avant de réinitialiser le système de coordonnées périodique,
et en corrigeant cette échelle par la suite.</p>
<div class="sourceCode" id="cb34" data-language="GLSL"
data-caption="Répétition de l&#39;espace avec espacement contrôlé"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">// repeter l&#39;espace tous les s unites</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">repeated</span><span class="op">(</span> <span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> s <span class="op">)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> r <span class="op">=</span> p <span class="op">-</span> s<span class="op">*</span><span class="bu">round</span><span class="op">(</span>p<span class="op">/</span>s<span class="op">);</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">sdf</span><span class="op">(</span>r<span class="op">);</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 class="unnumbered"
id="répétition-de-domaine-avec-identifiant">Répétition de domaine avec
identifiant</h3>
<p>La nature ne présente que rarement des formes parfaitement
régulières, de sorte que rien ne se reproduit à l’identique ou à des
intervalles strictement égaux. Il est donc souhaitable que chaque
instance de nos SDF se distingue légèrement, voire radicalement, des
autres.</p>
<p>La première étape consiste à définir un mécanisme permettant
d’identifier chaque instance au sein de notre grille infinie et de lui
attribuer un identifiant unique. Cette tâche est facilitée par la
fonction , qui nous permet de positionner notre système de coordonnées
sur l’entier le plus proche du domaine. Ainsi, cet entier devient un
identifiant unique pour chaque instance de SDF. Dans un espace 2D ou 3D,
cet identifiant sera également en 2D ou 3D, assurant ainsi un
identifiant distinct par dimension. En 3D, la création et l’utilisation
de cet identifiant se ferait en modifiant le code précédent comme suit
:</p>
<div class="sourceCode" id="cb35" data-language="GLSL"
data-caption="Répétition de l&#39;espace avec identifiant"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// repeter l&#39;espace tous les s unites</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">repeated</span><span class="op">(</span> <span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> s <span class="op">)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> id <span class="op">=</span> <span class="bu">round</span><span class="op">(</span>p<span class="op">/</span>s<span class="op">);</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> r <span class="op">=</span> p <span class="op">-</span> s<span class="op">*</span>id<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">sdf</span><span class="op">(</span>r<span class="op">,</span> id<span class="op">);</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 class="unnumbered" id="discontinuité">Discontinuité</h3>
<p>On peut exploiter cet identifiant pour moduler la taille de notre
SDF. Néanmoins, la méthode de répétition de domaine que nous avons
précédemment décrite présente une erreur, comme le montre l’image
ci-dessous (<a href="#repet03" data-reference-type="ref"
data-reference="repet03">[repet03]</a> et <a href="#repet04"
data-reference-type="ref" data-reference="repet04">1.28</a>). On observe
des discontinuités où les lignes de distance ne s’alignent pas
parfaitement. Une zone problématique est mise en évidence en jaune dans
la version agrandie de cette image. Ces discontinuités sont révélatrices
d’une SDF incorrectement définie.</p>
<figure id="repet04">
<img src="images/sdf/repet03.png" />
<img src="images/sdf/repet04.png" />
<figcaption>Discontinuité dans les lignes de distance</figcaption>
</figure>
<p>Le problème provient de l’usage de la fonction dans la fonction , qui
assigne chaque point à une cellule spécifique de la grille, ne
connaissant ainsi qu’une seule instance de . Bien que cela soit
efficace, cela échoue si l’instance la plus proche n’est pas dans la
même cellule que . Cette situation peut se produire si une cellule
voisine contient une instance significativement plus grande, rendant
l’instance la plus proche celle de cette cellule voisine.</p>
<p>Ce problème de distances incorrectes se produit en général lorsqu’on
effectue une opération qui casse la symétrie le long des frontières des
cellules (comme la rotation ou la mise à l’échelle).</p>
<h3 class="unnumbered" id="résoudre-le-problème">Résoudre le
problème</h3>
<p>Lorsque nous évaluons notre SDF au point avec notre fonction , il ne
suffit pas de se limiter à l’instance centrale de la cellule actuelle.
En effet, la forme la plus proche pourrait se situer dans une cellule
adjacente. Ainsi, nous devons vérifier les cellules voisines, évaluer et
déterminer la distance la plus courte parmi elles. Bien que cela puisse
paraître comme un nombre d’évaluations supplémentaires conséquentes de
(notre boîte arrondie ici), nous pouvons optimiser cette approche. Il
nous faut explorer uniquement les cellules voisines susceptibles de
contenir une instance plus proche que celle du point actuel. Ces
cellules se limitent aux côtés les plus proches de notre point
d’échantillonnage . Ainsi, en 2D, au lieu de vérifier les <span
class="math inline">\(9\)</span> cellules attendues (la cellule actuelle
et ses <span class="math inline">\(8\)</span> voisines), nous en
examinons seulement <span class="math inline">\(4\)</span> (la cellule
actuelle et <span class="math inline">\(3\)</span> voisines). En 1D,
nous échantillonnons <span class="math inline">\(2\)</span> cellules
(actuelle et une voisine) au lieu de <span
class="math inline">\(3\)</span>, et en 3D, ce sont <span
class="math inline">\(8\)</span> cellules (actuelle et <span
class="math inline">\(7\)</span> voisines) au lieu de <span
class="math inline">\(27\)</span>.</p>
<div class="sourceCode" id="cb36" data-language="GLSL"
data-caption="Résoudre le problème" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">repeated</span><span class="op">(</span> <span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">float</span> s <span class="op">)</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> id <span class="op">=</span> <span class="bu">round</span><span class="op">(</span>p<span class="op">/</span>s<span class="op">);</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span>  o <span class="op">=</span> <span class="bu">sign</span><span class="op">(</span>p<span class="op">-</span>s<span class="op">*</span>id<span class="op">);</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="fl">1e20</span><span class="op">;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span> <span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;</span><span class="dv">2</span><span class="op">;</span> j<span class="op">++</span> <span class="op">)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span> <span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">2</span><span class="op">;</span> i<span class="op">++</span> <span class="op">)</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> rid <span class="op">=</span> id <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span>i<span class="op">,</span>j<span class="op">)*</span>o<span class="op">;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> r <span class="op">=</span> p <span class="op">-</span> s<span class="op">*</span>rid<span class="op">;</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> <span class="bu">min</span><span class="op">(</span> d<span class="op">,</span> <span class="fu">sdf</span><span class="op">(</span>r<span class="op">)</span> <span class="op">);</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> d<span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Ici, la fonction se charge de déterminer si le voisin gauche ou droit
doit être vérifié pour la proximité de forme (ou haut contre face avant
et haut contre bas). La SDF ainsi calculée est correcte (voir <a
href="#repet05" data-reference-type="ref"
data-reference="repet05">[repet05]</a>).</p>
<figure id="shadat05">
<img src="images/sdf/repet05.png" />
<img src="images/shaders/shaderatelier_05.jpg" />
<figcaption>Répétition de l’espace</figcaption>
</figure>
<p>Nous observons également (<a href="#shadat05"
data-reference-type="ref" data-reference="shadat05">1.29</a>) que la
répétition de domaine peut être étendue aux coordonnées polaires plutôt
qu’aux coordonnées cartésiennes. Les coordonnées polaires constitueront
le sujet de notre prochaine section.</p>
<h1 id="la-pratique-du-livecoding-techniques-avancées">La pratique du
<em>livecoding</em> : techniques avancées</h1>
<div class="epigraph">
<p><em>Alt paa sin rette Plads!</em></p>
<p><em>Hans Christian Andersen</em></p>
</div>
<p>Une explication s’avère nécessaire quant au choix délibéré de
l’épigraphe située ci-dessus. <em>Alt paa sin rette Plads!</em> est à la
fois le titre d’un conte d’Andersen et une expression danoise qui se
traduit littéralement par « Tout à sa place correcte ! ». C’est un clin
d’œil à Andersen, célèbre pour ses contes adaptés en films d’animation
par Disney, bien que ces adaptations soient souvent très éloignées de
ses œuvres originales qui nous ont marqués, comme « La Petite Sirène »
ou « La Reine des Neiges ». Mais au-delà de cet hommage, c’est aussi une
manière pour moi de mettre en lumière le fait que l’écriture d’un
<em>shader</em> requiert un haut degré d’organisation, de logique, et ne
se base pas uniquement sur l’intuition. Avant l’art, il y a la
technique.</p>
<h2 id="coordonnées-polaires">Coordonnées polaires</h2>
<p>Le passage aux coordonnées polaires revêt une importance
particulière. En effet, il est courant d’utiliser les coordonnées
polaires pour passer d’un système de référence cartésien, tel qu’une
grille rectangulaire, à un système de référence circulaire, mieux adapté
à certaines formes comme les images <a href="#meduse_05_01"
data-reference-type="ref" data-reference="meduse_05_01">2.1</a> où l’on
voit que le rayon de la sphère est sculpté à intervalles réguliers sur
le plan <span class="math inline">\(XZ\)</span>.</p>
<figure id="meduse_05_01">
<img src="images/meduse/meduse_04.JPG" />
<img src="images/meduse/meduse_05_01.JPG" />
<figcaption>Rayon dépendant des coordonnées polaires</figcaption>
</figure>
<figure id="coord_polar">
<img src="images/shaders/coord_polar.png" style="width:50.0%" />
<figcaption>Géométrie des coordonnées polaires</figcaption>
</figure>
<p>Jusqu’à présent, nous avons travaillé avec les coordonnées
cartésiennes<a href="#fn20" class="footnote-ref" id="fnref20"
role="doc-noteref"><sup>20</sup></a>, où le centre de l’écran
correspondait à l’origine. À partir de ce système cartésien, nous
pouvons calculer les coordonnées polaires, permettant ainsi une
représentation de l’espace sous une forme circulaire. Alors que dans
l’espace cartésien 2D le <em>pixel</em> est décrit par ses coordonnées
<span class="math inline">\(X\)</span> et <span
class="math inline">\(Y\)</span>, dans le système de coordonnées
polaires, chaque <em>pixel</em> est défini par son angle <span
class="math inline">\(\theta\)</span> et sa distance <span
class="math inline">\(r\)</span> par rapport à l’origine. Dans le schéma
(<a href="#coord_polar" data-reference-type="ref"
data-reference="coord_polar">2.2</a>) le <em>pixel</em> n’est plus
défini en termes de <span class="math inline">\(X\)</span> et <span
class="math inline">\(Y\)</span> mais termes de <span
class="math inline">\(r\)</span> et de l’angle <span
class="math inline">\(\theta\)</span>.</p>
<p>En code nous utilisons la fonction trigonométrique pour obtenir
l’angle et à la fonction pour obtenir le rayon. Nous pouvons ensuite
stocker le résultat dans un vecteur (voir <a href="#polarX"
data-reference-type="ref" data-reference="polarX">[polarX]</a> et <a
href="#polarY" data-reference-type="ref"
data-reference="polarY">2.3</a>). Les images <a href="#polarX"
data-reference-type="ref" data-reference="polarX">[polarX]</a> et <a
href="#polarY" data-reference-type="ref" data-reference="polarY">2.3</a>
représentent respectivement l’angle des coordonnées uv et la distance
des <em>pixels</em> par rapport au centre.</p>
<div class="sourceCode" id="cb37" data-language="GLSL"
data-caption="Calculer les coordonnées polaires" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> pixel_angle <span class="op">=</span> <span class="bu">atan</span><span class="op">(</span>uv<span class="op">.</span><span class="fu">x</span><span class="op">,</span>uv<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> pixel_distance <span class="op">=</span>  <span class="bu">length</span><span class="op">(</span>uv<span class="op">)*</span> <span class="fl">2.0</span> <span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> st <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>pixel_angle <span class="op">,</span> pixel_distance<span class="op">);</span></span></code></pre></div>
<figure id="polarY">
<img src="images/polarX.JPG" />
<img src="images/polarY.JPG" />
<figcaption>Contenu de la variable </figcaption>
</figure>
<p>Cependant, la représentation de l’angle n’est pas correcte car la
fonction renvoie l’angle en radians compris entre <span
class="math inline">\(0\)</span> et <span
class="math inline">\(2\pi\)</span>. Pour corriger cela, il est
nécessaire de remapper<a href="#fn21" class="footnote-ref" id="fnref21"
role="doc-noteref"><sup>21</sup></a> ces valeurs dans l’intervalle de
<span class="math inline">\(0\)</span> à <span
class="math inline">\(1\)</span> en divisant le résultat par <span
class="math inline">\(2\pi\)</span> (voir <a href="#polar00"
data-reference-type="ref" data-reference="polar00">[polar00]</a>).
Cependant, même après ce remappage, la moitié gauche de l’écran reste
complètement noire en raison des valeurs négatives. Pour résoudre ce
problème, nous ajoutons <span class="math inline">\(0.5\)</span> au
résultat pour obtenir un dégradé complet (voir <a href="#polar01"
data-reference-type="ref" data-reference="polar01">2.4</a>).</p>
<div class="sourceCode" id="cb38" data-language="GLSL"
data-caption="Remap de l&#39;angle" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>st<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> PI_2 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">);</span></span></code></pre></div>
<figure id="polar01">
<img src="images/polar00.JPG" />
<img src="images/polar01.JPG" />
<figcaption>Après avoir ajouté <span
class="math inline">\(0.5\)</span></figcaption>
</figure>
<p>Lorsque nous assignons une texture dans ces coordonnées polaires,
nous obtenons effectivement une représentation circulaire (voir <a
href="#polar02" data-reference-type="ref"
data-reference="polar02">[polar02]</a>).</p>
<figure id="tent01">
<img src="images/polar02.JPG" />
<img src="images/meduse/meduse_06_1.JPG" />
<figcaption>Tentacules grâce aux coordonnées polaires</figcaption>
</figure>
<p>En combinaison avec la répétition de l’espace on pourrait aussi
sectoriser l’espace des coordonnées polaires, afin par exemple de
pouvoir créer tentacules ou tout autre objet à intervalles réguliers
(voir <a href="#tent01" data-reference-type="ref"
data-reference="tent01">2.5</a>).</p>
<h2
id="post-traitement-application-dune-texture-sur-un-objet">Post-traitement
: application d’une texture sur un objet</h2>
<p>Les effets de post-traitement<a href="#fn22" class="footnote-ref"
id="fnref22" role="doc-noteref"><sup>22</sup></a> (<em>post-process</em>
en anglais), tels que le flou<a href="#fn23" class="footnote-ref"
id="fnref23" role="doc-noteref"><sup>23</sup></a> ou l’aberration
chromatique<a href="#fn24" class="footnote-ref" id="fnref24"
role="doc-noteref"><sup>24</sup></a>, sont finalement relativement
simples à implémenter dans le <em>fragment shader</em> (voir <a
href="#blur00" data-reference-type="ref"
data-reference="blur00">[blur00]</a> et <a href="#chr_ab00"
data-reference-type="ref" data-reference="chr_ab00">2.6</a> ).</p>
<figure id="chr_ab00">
<img src="images/post_process/blur00.JPG" />
<img src="images/post_process/chr_ab00.JPG" />
<figcaption>Aberration chromatique</figcaption>
</figure>
<p>En OpenGL, la texture d’origine serait gérée dans un <em>frame
buffer</em><a href="#fn25" class="footnote-ref" id="fnref25"
role="doc-noteref"><sup>25</sup></a> plutôt compliqué à manipuler.
Cependant, dans des environnements de développement tels que Shadertoy
ou KodeLife la démarche est plus aisée car il suffit de créer des passes
successives (voir <a href="#shadertoy00" data-reference-type="ref"
data-reference="shadertoy00">[shadertoy00]</a> et <a href="#kodelife000"
data-reference-type="ref" data-reference="kodelife000">2.7</a>).</p>
<p>En pratique, il suffit d’appliquer un <em>shader</em> d’effet sur un
<em>shader</em> d’origine (voir <a href="#mapuv01"
data-reference-type="ref" data-reference="mapuv01">[mapuv01]</a> et <a
href="#mapuv00" data-reference-type="ref"
data-reference="mapuv00">2.8</a>), qui sera interprété comme une
texture. Dans l’image <a href="#mapuv00" data-reference-type="ref"
data-reference="mapuv00">2.8</a>, nous avons appliqué un <em>shader</em>
en tant que texture sur une télévision.</p>
<p>Il est à noter que le <em>shader</em> d’origine utilise les
L-systèmes<a href="#fn26" class="footnote-ref" id="fnref26"
role="doc-noteref"><sup>26</sup></a>, également connus sous le nom de
systèmes de Lindenmayer, pour représenter l’arbre.</p>
<figure id="kodelife000">
<img src="images/shaders/shadertoy00.png" />
<img src="images/shaders/kodelife00.png" />
<figcaption><em>Post-process</em> dans KodeLife</figcaption>
</figure>
<figure id="mapuv00">
<img src="images/shaders/mapuv01.png" />
<img src="images/shaders/mapuv00.png" />
<figcaption>Mappage d’une texture sur un cube qui tourne</figcaption>
</figure>
<p>Grâce à la technique du <em>ray marching</em>, nous créons la scène
constituée d’un cube qui tourne pour représenter une télévision et d’un
cube vu de l’intérieur qui représente la pièce. Lorsque le rayon touche
la pièce, nous appliquons un éclairage classique. En revanche, lorsque
nous touchons le téléviseur, nous voulons appliquer la texture. La
difficulté rencontrée réside donc dans la récupération des bonnes
valeurs de coordonnées de l’espace sur lequel nous allons appliquer la
texture. La principale difficulté en termes de code est de bien penser à
sauvegarder l’espace de la SDF qui tourne dans une variable globale.</p>
<div class="sourceCode" id="cb39" data-language="GLSL"
data-caption="Sauvegarde de l&#39;espace dans une variable globale"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// variable globale pour sauvegarder </span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">// l espace de la tv qui tourne pour mapper la texture plus tard</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> ptv<span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">// la description de la scene refactorisee, renvoie la distance + un id</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">map</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">(...)</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on sauvegarde un espace dedie pour le cube qui tourne</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> p2 <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on le translate en Y</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    p2 <span class="op">-=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.</span><span class="op">,-</span><span class="fl">1.5</span><span class="op">+</span><span class="bu">sin</span><span class="op">(</span>iTime<span class="op">),</span><span class="fl">5.</span><span class="op">);</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on le rot sur Y</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    p2<span class="op">.</span><span class="fu">xz</span> <span class="op">*=</span> <span class="fu">r2d</span><span class="op">(</span>iTime<span class="op">);</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// important: on sauvegarde l espace dans la variable globale en vue</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// de dessiner la texture</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    ptv <span class="op">=</span> p2<span class="op">;</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// une variable pour controler l effet bombe de la tv</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> thick <span class="op">=</span> <span class="bu">mix</span><span class="op">(.</span><span class="fu">4</span><span class="op">,.</span><span class="fu">2</span><span class="op">,</span><span class="bu">sin</span><span class="op">(</span>p2<span class="op">.</span><span class="fu">y</span><span class="op">*</span><span class="fl">2.</span><span class="op">-</span><span class="fl">1.57</span><span class="op">)*.</span><span class="fu">5</span><span class="fl">+.5</span><span class="op">);</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> tv <span class="op">=</span> <span class="fu">_cube</span><span class="op">(</span>p2<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.</span><span class="op">,</span><span class="fl">0.7</span><span class="op">,</span>thick<span class="op">)*</span><span class="fl">2.</span><span class="op">);</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//room = min(room, length(p2)-1.);  </span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on l&#39;ajoute</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    acc <span class="op">=</span> <span class="fu">_min</span><span class="op">(</span>acc<span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span>tv<span class="op">,</span> <span class="fl">1.</span><span class="op">));</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> acc<span class="op">;</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>De cette manière, nous pouvons réutiliser cet espace au moment du
rendu du téléviseur. En discriminant les objets, nous pouvons déterminer
quand nous faisons référence au téléviseur. En ajoutant une condition
sur la profondeur, nous sommes en mesure de projeter la texture
uniquement sur la face avant de l’objet.</p>
<div class="sourceCode" id="cb40" data-language="GLSL"
data-caption="Mapper des textures" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// dans la fonction de  \textit{ray marching}</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>res<span class="op">.</span><span class="fu">y</span> <span class="op">==</span> <span class="fl">1.</span> <span class="op">&amp;&amp;</span> ptv<span class="op">.</span><span class="fu">z</span> <span class="op">&lt;</span> <span class="fl">0.</span><span class="op">)</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// on projette la texture sur XY</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// bien penser a equilibrer les valeurs</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> <span class="bu">texture</span><span class="op">(</span>iChannel0<span class="op">,</span> ptv<span class="op">.</span><span class="fu">xy</span><span class="op">*</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">1.</span><span class="op">,</span><span class="fl">2.</span><span class="op">)*.</span><span class="fu">25</span><span class="fl">+.5</span><span class="op">+</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.</span><span class="op">,.</span><span class="fu">5</span><span class="op">)).</span><span class="fu">xyz</span><span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="le-bruit">Le bruit</h2>
<h3 class="unnumbered" id="introduction-2">Introduction</h3>
<p>Dans le domaine des images de synthèse, un défi récurrent est
l’apparence souvent trop lisse et parfaite de ces rendus. Dans la
nature, les objets présentent des aspérités, des irrégularités et
diverses imperfections.</p>
<p>La problématique centrale réside dans la recherche de méthodes pour
intégrer cette complexité naturelle dans les images générées. Bien qu’il
soit tentant de capturer des images réelles pour simuler un aspect plus
naturel, une approche alternative consiste à recourir aux mathématiques
pour générer des motifs qui, bien que déterministes, donnent l’illusion
de l’aléatoire. En ajustant judicieusement les paramètres, on peut
obtenir des résultats qui semblent naturellement aléatoires, ouvrant
ainsi des perspectives intéressantes pour améliorer nos
<em>shaders</em>.</p>
<figure>
<div class="center">
<img src="images/shaders/shaderatelier_13.jpg" style="width:10cm" />
</div>
<figcaption>Un terrain dont le relief dépend du bruit</figcaption>
</figure>
<h3 class="unnumbered" id="random-en-code"><em>Random</em> en code</h3>
<h4 class="unnumbered" id="random-unidimensionnel"><em>Random</em>
unidimensionnel</h4>
<p>Pour obtenir une génération pseudo-aléatoire mathématique, nous
établissons une fonction qui prend un nombre en entrée et retourne un
résultat aléatoire compris entre <span class="math inline">\(0\)</span>
et <span class="math inline">\(1\)</span>. Dans notre approche initiale,
la coordonnée est utilisée comme référence pour ce calcul.</p>
<p>Ce nombre est ensuite intégré dans une fonction sinusoïdale, le
positionnant ainsi sur cette courbe. Pour augmenter la complexité de
notre fonction, nous multiplions ce nombre par un facteur important,
intensifiant la fréquence de l’onde sinusoïdale.</p>
<p>Étant donné que l’onde sinusoïdale a une amplitude oscillant entre
<span class="math inline">\(-1\)</span> et <span
class="math inline">\(1\)</span>, nous ajustons notre résultat en le
multipliant par un coefficient. Cela élargit la plage d’amplitude,
faisant varier les valeurs entre des niveaux bien plus élevés et plus
bas. Enfin, nous utilisons la fonction pour extraire la partie
fractionnaire de ce résultat.</p>
<div class="sourceCode" id="cb41" data-language="GLSL"
data-caption="Random unidimensionnel" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> c <span class="op">=</span> <span class="bu">fract</span><span class="op">(</span><span class="bu">sin</span><span class="op">(</span>uv<span class="op">.</span><span class="fu">x</span><span class="op">*</span><span class="fl">100.</span><span class="op">)*</span><span class="fl">5647.</span><span class="op">);</span></span></code></pre></div>
<p>Le rendu final présente un schéma similaire à un code-barres, où
chaque colonne de <em>pixels</em> affiche des nuances de couleurs
variées, oscillant entre le noir et le blanc (voir <a href="#noise00"
data-reference-type="ref" data-reference="noise00">[noise00]</a> et <a
href="#noise01" data-reference-type="ref"
data-reference="noise01">2.9</a>).</p>
<figure id="noise01">
<img src="images/noise/noise00.JPG" />
<img src="images/noise/noise01.JPG" />
<figcaption>Random unidimensionnel sur <span
class="math inline">\(Y\)</span></figcaption>
</figure>
<h4 class="unnumbered" id="random-bidimensionnel"><em>Random</em>
bidimensionnel</h4>
<p>Le prochain objectif est de produire une représentation
bidimensionnelle du bruit aléatoire, similaire au grain présent sur les
anciennes télévisions cathodiques. Pour parvenir à cela, nous incluons
la composante dans notre calcul de génération pseudo-aléatoire, en
utilisant une fréquence significativement supérieure à celle de la
composante (voir <a href="#noise02" data-reference-type="ref"
data-reference="noise02">[noise02]</a>).</p>
<p>Il est possible de varier ces paramètres pour obtenir diverses sortes
de motifs (<em>patterns</em><a href="#fn27" class="footnote-ref"
id="fnref27" role="doc-noteref"><sup>27</sup></a> en anglais). Il est à
noter que les résultats peuvent légèrement varier selon la carte
graphique utilisée.</p>
<p>Il est possible de regrouper ces calculs au sein d’une fonction, non
seulement pour améliorer la lisibilité du code, mais également pour
faciliter sa réutilisation. Nous nommons cette fonction car elle accepte
une coordonnée 2D en entrée et produit un nombre flottant aléatoire dans
l’intervalle <span class="math inline">\([0, 1]\)</span>.</p>
<div class="sourceCode" id="cb42" data-language="GLSL"
data-caption="Random bidimensionnel" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">N21</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">)</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">fract</span><span class="op">(</span><span class="bu">sin</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">*</span><span class="fl">100.</span><span class="op">+</span> p<span class="op">.</span><span class="fu">y</span><span class="op">*</span><span class="fl">546.</span><span class="op">)*</span><span class="fl">5647.</span><span class="op">);</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure id="noise03">
<img src="images/noise/noise02.JPG" />
<img src="images/noise/noise03.JPG" />
<figcaption>Apparition de motifs</figcaption>
</figure>
<p>L’inconvénient majeur de cette approche, est que lorsque nous zoomons
sur les uv, on distingue un motif qui montre que ce n’est pas de
l’aléatoire mais du pseudo-aléatoire (voir <a href="#noise03"
data-reference-type="ref" data-reference="noise03">2.10</a>).</p>
<h3 class="unnumbered" id="value-noise">Value <em>noise</em></h3>
<p>Une autre méthode pour générer de l’aléatoire consiste à utiliser
l’interpolation. Nous commençons par établir une grille de cellules en
appliquant la fonction à des coordonnées uv multipliées. Chaque cellule
est définie par des coordonnées variant dans l’intervalle <span
class="math inline">\([0,1]\)</span> tant en <span
class="math inline">\(X\)</span> qu’en <span
class="math inline">\(Y\)</span>. Il nous faut également un identifiant
pour déterminer dans quelle cellule nous nous trouvons. La fonction nous
permet d’obtenir la partie entière d’un nombre. Les fonctions et sont
complémentaires. Par exemple, retourne <span
class="math inline">\(0.53\)</span>, tandis que retourne <span
class="math inline">\(1\)</span> (voir <a href="#noise04"
data-reference-type="ref" data-reference="noise04">[noise04]</a> et <a
href="#noise05" data-reference-type="ref"
data-reference="noise05">2.11</a>).</p>
<figure id="noise05">
<img src="images/noise/noise04.JPG" />
<img src="images/noise/noise05.JPG" />
<figcaption>La fonction </figcaption>
</figure>
<div class="sourceCode" id="cb43" data-language="GLSL"
data-caption="Les fonctions \custominline{fract()} et \custominline{floor()}"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>uv<span class="op">*=</span><span class="fl">10.</span><span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> lv <span class="op">=</span> <span class="bu">fract</span><span class="op">(</span>uv<span class="op">);</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>uv<span class="op">);</span></span></code></pre></div>
<p>Pour chaque coin de ces cellules, nous appliquons notre fonction de
bruit, générant ainsi une valeur aléatoire pour chaque coin. Puis nous
interpolons les valeurs en trois étapes. D’abord entre les coins
inférieurs et les coins supérieurs sur l’axe horizontal, et enfin avec
une interpolation entre ces résultats sur l’axe vertical.</p>
<div class="sourceCode" id="cb44" data-language="GLSL"
data-caption="Interpolation pour chaque cellule" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> bl <span class="op">=</span> <span class="fu">N21</span><span class="op">(</span>id<span class="op">);</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> br <span class="op">=</span> <span class="fu">N21</span><span class="op">(</span>id<span class="op">+</span><span class="dt">vec2</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">// interpolation entre les coins bas gauche et bas droite selon X</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> b <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>bl<span class="op">,</span>br<span class="op">,</span>lv<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> ul <span class="op">=</span> <span class="fu">N21</span><span class="op">(</span>id<span class="op">+</span><span class="dt">vec2</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> ur <span class="op">=</span> <span class="fu">N21</span><span class="op">(</span>id<span class="op">+</span><span class="dt">vec2</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="co">// interpolation entre les coins haut gauche et haut droite selon X</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> u <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>ul<span class="op">,</span>ur<span class="op">,</span>lv<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co">// interpolation des valeur calculees selon Y</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> c <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>b<span class="op">,</span>u<span class="op">,</span>lv<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span></code></pre></div>
<figure id="noise07">
<img src="images/noise/noise06.JPG" />
<img src="images/noise/noise07.JPG" />
<figcaption>Adoucissement du <em>noise</em></figcaption>
</figure>
<p>Le rendu obtenu est plus doux que celui précédemment obtenu.
Cependant, un inconvénient est que les frontières entre nos cellules
sont visibles, créant ainsi des halos en forme de croix, comme illustré
dans l’image <a href="#noise06" data-reference-type="ref"
data-reference="noise06">[noise06]</a>. Ce phénomène est dû à la nature
linéaire de notre interpolation. En effet, sur notre grille , les
valeurs progressent de manière linéaire de <span
class="math inline">\(0\)</span> à <span
class="math inline">\(1\)</span>. Grâce à la fonction , nous avons la
possibilité d’atténuer cette linéarité, permettant à l’évolution des
valeurs de suivre une trajectoire en « S » plutôt qu’une ligne droite.
Le résultat est visible dans l’image <a href="#noise07"
data-reference-type="ref" data-reference="noise07">2.12</a>.</p>
<div class="sourceCode" id="cb45" data-language="GLSL"
data-caption="\custominline{smoothstep()} pour adoucir le bruit"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> lv <span class="op">=</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="bu">fract</span><span class="op">(</span>uv<span class="op">));</span></span></code></pre></div>
<h3 class="unnumbered" id="perlin-noise">Perlin <em>noise</em></h3>
<p>Le bruit de Perlin<a href="#fn28" class="footnote-ref" id="fnref28"
role="doc-noteref"><sup>28</sup></a>, bien qu’étroitement lié au
<em>value noise</em>, produit généralement des résultats de meilleure
qualité. Une méthode alternative pour son calcul consiste à évaluer la
colinéarité entre un vecteur aléatoire et le vecteur s’étendant du coin
de chaque cellule vers son centre (voir <a href="#noise12"
data-reference-type="ref" data-reference="noise12">[noise12]</a> et <a
href="#noise13" data-reference-type="ref"
data-reference="noise13">2.13</a>).</p>
<figure id="noise13">
<img src="images/noise/noise12.JPG" />
<img src="images/noise/noise13.JPG" />
<figcaption>Degré de colinéarité avec le vecteur dirigé vers le centre
de chaque cellule</figcaption>
</figure>
<h3 class="unnumbered" id="billow-noise"><em>Billow noise</em></h3>
<p>Le <em>Billow noise</em> est une variante du bruit de Perlin qui
produit une apparence de nuage ou de fumée. Il est caractérisé par des
transitions douces et des formes arrondies, donnant un aspect ondulé ou
nuageux. Contrairement au bruit standard qui varie linéairement entre
<span class="math inline">\(-1\)</span> et <span
class="math inline">\(1\)</span>, le <em>Billow noise</em> utilise des
valeurs absolues des contributions du bruit, créant des formes plus
arrondies et douces (voir <a href="#noise10" data-reference-type="ref"
data-reference="noise10">[noise10]</a>).</p>
<div class="sourceCode" id="cb46" data-language="GLSL"
data-caption="\textit{Billow noise}" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// billow</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> billow <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>perlin<span class="op">);</span></span></code></pre></div>
<figure id="noise11">
<img src="images/noise/noise10billow.JPG" />
<img src="images/noise/noise11ridged.JPG" />
<figcaption><em>Ridge</em> <em>Noise</em></figcaption>
</figure>
<h3 class="unnumbered" id="ridge-noise"><em>Ridge noise</em></h3>
<p>Le <em>Ridge noise</em> est une autre variante du bruit de Perlin qui
produit des crêtes ou des formations montagneuses. Il est similaire au
<em>Billow noise</em>, mais utilise des valeurs négatives pour certaines
composantes du bruit, créant des formes pointues ou en crêtes. Cette
caractéristique lui permet de générer des terrains avec des sommets
pointus et des vallées profondes, donnant un aspect plus accidenté ou
montagneux (voir <a href="#noise11" data-reference-type="ref"
data-reference="noise11">2.14</a>).</p>
<div class="sourceCode" id="cb47" data-language="GLSL"
data-caption="\textit{Ridge noise}" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> ridged <span class="op">=</span> <span class="fl">1.0</span><span class="op">-</span> <span class="bu">abs</span><span class="op">(</span>perlin<span class="op">);</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>ridged <span class="op">=</span> ridged<span class="op">*</span>ridged<span class="op">;</span></span></code></pre></div>
<h3 class="unnumbered" id="voronoi-worley">Voronoi / Worley</h3>
<p>Diverses fonctions de bruit génèrent des effets différents. Nous
avons abordé le <em>value noise</em>, une forme de bruit doux couramment
utilisée pour élaborer des terrains procéduraux infinis, à l’image de
ceux de Minecraft ou No Man’s Sky.</p>
<p>Le Voronoi est particulièrement adapté pour créer des motifs
organiques rappelant des structures naturelles comme les ailes de
libellule, les nervures de feuilles ou encore les taches de la peau des
girafes. Il constitue également une base solide pour simuler des nuages
réalistes. Ainsi, le bruit de Voronoi peut représenter une technique à
inclure dans une boîte à outils dédiée à la conception de
<em>shaders</em>.</p>
<figure id="noise15">
<img src="images/noise/noise14.JPG" />
<img src="images/noise/noise15.JPG" />
<figcaption>Voronoi 15</figcaption>
</figure>
<p>La mise en place du Voronoi débute par la création d’une grille de
cellules, exactement comme pour le <em>value noise</em> (voir <a
href="#noise04" data-reference-type="ref"
data-reference="noise04">[noise04]</a>). Chaque cellule de cette grille
peut inclure un point central (voir <a href="#noise16"
data-reference-type="ref" data-reference="noise16">[noise16]</a>). Par
la suite, une itération est effectuée sur chaque <em>pixel</em> afin de
calculer la distance minimale vers le point le plus proche (voir <a
href="#noise17" data-reference-type="ref"
data-reference="noise17">2.16</a>).</p>
<figure id="noise17">
<img src="images/noise/noise16.JPG" />
<img src="images/noise/noise17.JPG" />
<figcaption>Voronoi: affichage des distances</figcaption>
</figure>
<p>Visuellement, il est manifeste que chaque <em>pixel</em> identifie
son point le plus proche à l’intérieur de sa cellule respective. Une
représentation graphique de cette distance produit une distribution
uniforme des résultats.</p>
<p>Pour apporter une touche plus organique à cette démarche, des
décalages peuvent être ajoutés aux points de la grille grâce à l’ajout
de bruit. Il est à noter que cette incorporation de bruit entraîne une
augmentation du nombre de vérifications dans l’algorithme. Ainsi, chaque
<em>pixel</em> doit déterminer le point le plus proche au sein de sa
cellule actuelle et dans les huit cellules adjacentes.</p>
<div class="sourceCode" id="cb48" data-language="GLSL"
data-caption="Voronoi" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> minDistFromPixel<span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> <span class="op">(</span><span class="dt">float</span> i <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="fl">1.0</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> <span class="op">(</span><span class="dt">float</span> j <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="fl">1.0</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">vec2</span> adjGridCoords <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">vec2</span> pointOnAdjGrid <span class="op">=</span> adjGridCoords<span class="op">;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">vec2</span> <span class="bu">noise</span> <span class="op">=</span> <span class="fu">noise2x2</span><span class="op">(</span>currentGridId <span class="op">+</span> adjGridCoords<span class="op">);</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>      pointOnAdjGrid <span class="op">=</span> adjGridCoords <span class="op">+</span> <span class="bu">sin</span><span class="op">(</span>iTime <span class="op">*</span> <span class="bu">noise</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">float</span> dist <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>currentGridCoord <span class="op">-</span> pointOnAdjGrid<span class="op">);</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>      minDistFromPixel <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>dist<span class="op">,</span> minDistFromPixel<span class="op">);</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>      pointsOnGrid <span class="op">+=</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.95</span><span class="op">,</span> <span class="fl">0.96</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">-</span> dist<span class="op">);</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Pour simuler des nuages, il suffit de soustraire la distance minimale
du <em>pixel</em> dans le code, ce qui rendra une apparence
nuageuse.</p>
<h2 id="le-fractional-brownian-motion">Le <em>Fractional Brownian
Motion</em></h2>
<p>Le <em>Fractional Brownian Motion</em> (FBM) est une technique qui,
malgré son nom complexe, se révèle assez simple à mettre en œuvre en
<em>livecoding</em> pour ceux qui maîtrisent déjà les concepts du bruit.
En résumé, la technique du FBM consiste à superposer des couches de
bruit afin de composer une texture très détaillée présentant des
propriétés d’auto-similarité, présentes aussi dans les fractales (voir
<a href="#noise09" data-reference-type="ref"
data-reference="noise09">[noise09]</a> et <a href="#noise08"
data-reference-type="ref" data-reference="noise08">2.17</a>).</p>
<figure id="noise08">
<img src="images/noise/noise09.JPG" />
<img src="images/noise/noise08.JPG" />
<figcaption>FBM avec quatre calques</figcaption>
</figure>
<p>Par analogie avec la musique, cette approche de superposition de
bruits est souvent qualifiée d’ajout d’octaves de bruit. À chaque
nouvelle octave, nous doublons la fréquence et ajustons l’amplitude en
conséquence. Bien que chaque octave apporte sa propre richesse visuelle,
la combinaison de plusieurs octaves crée une texture plus détaillée,
offrant des possibilités de représentation pour des éléments variés tels
que les nuages, les vagues, les montagnes, etc (voir <a href="#fbm00"
data-reference-type="ref" data-reference="fbm00">[fbm00]</a> et <a
href="#fbm01" data-reference-type="ref"
data-reference="fbm01">2.18</a>).</p>
<div class="sourceCode" id="cb49" data-language="GLSL"
data-caption="FBM" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> c <span class="op">=</span> <span class="fu">SmoothNoise</span><span class="op">(</span>uv<span class="op">*</span><span class="fl">4.</span><span class="op">)*</span><span class="fl">1.</span><span class="op">;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>c<span class="op">+=</span> <span class="fu">SmoothNoise</span><span class="op">(</span>uv<span class="op">*</span><span class="fl">8.</span><span class="op">)*.</span><span class="fu">50</span><span class="op">;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>c<span class="op">+=</span> <span class="fu">SmoothNoise</span><span class="op">(</span>uv<span class="op">*</span><span class="fl">16.</span><span class="op">)*.</span><span class="fu">25</span><span class="op">;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>c<span class="op">+=</span> <span class="fu">SmoothNoise</span><span class="op">(</span>uv<span class="op">*</span><span class="fl">32.</span><span class="op">)*.</span><span class="fu">125</span><span class="op">;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>c<span class="op">+=</span> <span class="fu">SmoothNoise</span><span class="op">(</span>uv<span class="op">*</span><span class="fl">64.</span><span class="op">)*.</span><span class="fu">0625</span><span class="op">;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>c<span class="op">/=(</span><span class="fl">1.</span><span class="op">+.</span><span class="fu">5</span><span class="op">);</span></span></code></pre></div>
<figure id="fbm01">
<img src="images/post_process/fbm00.JPG" />
<img src="images/post_process/fbm01.JPG" />
<figcaption>Génération de terrain avec le FBM par amuda</figcaption>
</figure>
<h2 id="les-ombres">Les ombres</h2>
<p>Le calcul des ombres est en réalité plus simple qu’il n’y paraît.
Actuellement, nous utilisons notre méthode de <em>ray marching</em> pour
identifier un point de la scène en contact avec nos objets (voir <a
href="#shad00" data-reference-type="ref"
data-reference="shad00">[shad00]</a>). Cette même méthode peut être
réutilisée pour générer un second rayon pointant vers la source
lumineuse de la scène. Si ce rayon intersecte un objet lors de son
trajet entre le point sur la surface et la source lumineuse, cela
signifie qu’il y a une occlusion et que le point sur la surface se
trouve dans l’ombre.</p>
<figure id="shad01">
<img src="images/shaders/shad00.png" />
<img src="images/shaders/shad01.png" />
<figcaption>Scène avec le calcul des ombres</figcaption>
</figure>
<p>Dans notre implémentation GLSL, nous répéterons le <em>ray
marching</em> une seconde fois, en prenant comme origine le point ,
découvert lors de la première étape du <em>ray marching</em> lorsque
nous avons identifié les objets de la scène. La direction du nouveau
rayon sera définie par . Dans notre code, cela se traduit simplement par
l’ajout de trois lignes après le calcul de la réflexion diffuse.</p>
<div class="sourceCode" id="cb50" data-language="GLSL"
data-caption="Calcul des ombres" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dif <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDirection<span class="op">),</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">);</span> </span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">// diffuse reflection clamped between zero and one</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> newRayOrigin <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">// cast shadow ray to the light source</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> shadowRayLength <span class="op">=</span> <span class="fu">rayMarch</span><span class="op">(</span>newRayOrigin<span class="op">,</span> lightDirection<span class="op">);</span> </span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>shadowRayLength <span class="op">&lt;</span> <span class="bu">length</span><span class="op">(</span>lightPosition <span class="op">-</span> newRayOrigin<span class="op">))</span> dif <span class="op">*=</span> <span class="fl">0.</span><span class="op">;</span> </span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="co">// if the shadow ray hits the sphere,</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="co">// set the diffuse reflection to zero,</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="co">// simulating a shadow</span></span></code></pre></div>
<p>Lors de l’exécution du code, l’écran affiche presque entièrement un
noir total. Cette obscurité est en réalité due à une raison assez
intuitive. Lorsque nous lançons notre second rayon de <em>ray
marching</em> vers la source lumineuse, l’algorithme considère le point
, qui est en contact direct avec la surface. Par conséquent, dès le
premier tour de la boucle, l’algorithme détecte une collision avec un
objet, faisant ainsi croire que la plupart de la scène est dans l’ombre,
d’où l’écran noir.</p>
<p>Pour résoudre ce problème, il est nécessaire de décaler légèrement le
point d’origine du second rayon par rapport à . Fort heureusement, nous
sommes en mesure de calculer la normale au point de la surface, ce qui
nous permet de nous éloigner subtilement de la surface en suivant la
direction de cette normale. Une méthode couramment employée consiste à
ajouter la normale du point de la surface, multipliée par une petite
valeur, à la position de , afin d’obtenir un point voisin plus approprié
pour l’origine du second rayon.</p>
<div class="sourceCode" id="cb51" data-language="GLSL"
data-caption="S&#39;éloigner de la surface" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> newRayOrigin <span class="op">=</span> p <span class="op">+</span> normal <span class="op">*</span> PRECISION<span class="op">;</span></span></code></pre></div>
<p>L’ombre apparaît encore assez sombre. Pour la rendre plus claire,
nous pouvons ajuster la proportion de la réflexion diffuse.
Actuellement, nous attribuons la couleur de la réflexion diffuse à zéro
pour les points identifiés comme étant dans l’ombre. En modifiant le «
facteur d’échelle » et en le fixant à <span
class="math inline">\(0.2\)</span>, nous pouvons obtenir une ombre plus
légère et plus réaliste (voir <a href="#shad01"
data-reference-type="ref" data-reference="shad01">2.19</a>).</p>
<div class="sourceCode" id="cb52" data-language="GLSL"
data-caption="Ajuster la proportion de la réflexion diffuse"
data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>shadowRayLength <span class="op">&lt;</span> <span class="bu">length</span><span class="op">(</span>lightPosition <span class="op">-</span> newRayOrigin<span class="op">))</span> dif <span class="op">*=</span> <span class="fl">0.2</span><span class="op">;</span> </span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">// shadow</span></span></code></pre></div>
<p>L’ombre est désormais plus esthétique, permettant d’apercevoir la
couleur diffuse du sol à travers elle.</p>
<h2 id="le-glow">Le <em>glow</em></h2>
<p>Le <em>glow</em><a href="#fn29" class="footnote-ref" id="fnref29"
role="doc-noteref"><sup>29</sup></a>, ou effet de brillance, désigne
cette capacité d’un objet à paraître lumineux à émettre de la lumière.
Dans notre environnement quotidien, plusieurs éléments naturels ou
artificiels présentent cette caractéristique, tels que les lucioles, les
ampoules, les méduses et même les étoiles dans le ciel. Ces entités
peuvent émettre une lumière qui illumine leur environnement, qu’il
s’agisse d’une lumière discrète s’étendant sur une courte distance ou
d’une lueur intense comparable à celle de la pleine lune.</p>
<p>Pour obtenir un effet de <em>glow</em> réussi, il est crucial
d’assurer un contraste prononcé entre la teinte de l’objet et celle de
son fond, ainsi qu’un dégradé coloré qui s’atténue progressivement à
mesure que l’on s’éloigne de l’objet. En observant ces deux critères,
nous pouvons élaborer un effet lumineux efficace (voir <a href="#glow1"
data-reference-type="ref" data-reference="glow1">[glow1]</a>).</p>
<p>Dans le contexte du code, les SDF génèrent une valeur de distance
signée indiquant la distance par rapport à un objet donné. Il convient
de rappeler que les <em>shaders</em> dessinent chaque <em>pixel</em> de
manière parallèle, ce qui signifie que chaque <em>pixel</em> est
positionné à une distance définie de l’objet. Ensuite, nous avons la
possibilité de créer une fonction qui introduira un effet de
<em>glow</em> proportionnel à la distance par rapport au centre de
l’objet. Pour illustrer cette fonction, Desmos<a href="#fn30"
class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a>
peut être utilisé en saisissant l’équation <span class="math inline">\(y
= \frac{1}{x}\)</span>. Dans ce contexte, <span
class="math inline">\(x\)</span> représente la valeur de distance signée
pour l’objet. À mesure que cette valeur s’accroît, la sortie, <span
class="math inline">\(y\)</span>, se réduit (voir <a href="#glow2"
data-reference-type="ref" data-reference="glow2">2.20</a>).</p>
<figure id="glow2">
<img src="images/shaders/glow1.png" />
<img src="images/shaders/glow2.png" />
<figcaption>Distance du <em>glow</em></figcaption>
</figure>
<p>La fonction <span class="math inline">\(y = \frac{1}{x}\)</span> peut
générer des valeurs imprévues lorsque <span
class="math inline">\(x\)</span> est négatif (<span
class="math inline">\(x\leq0\)</span>). Cette situation peut conduire le
compilateur à réaliser des calculs inhabituels, ce qui entraîne des
couleurs non anticipées. Pour pallier ce problème, nous pouvons faire
appel à la fonction afin de s’assurer que la valeur de l’effet de
<em>glow</em> demeure comprise entre <span
class="math inline">\(0\)</span> et <span
class="math inline">\(1\)</span> (voir <a href="#glow3"
data-reference-type="ref" data-reference="glow3">[glow3]</a>).</p>
<div class="sourceCode" id="cb53" data-language="GLSL"
data-caption="Glow" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>uv<span class="op">)</span> <span class="op">-</span> <span class="fl">0.2</span><span class="op">;</span> <span class="co">// signed distance function</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> col <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="bu">step</span><span class="op">(</span><span class="fl">0.</span><span class="op">,</span> <span class="op">-</span>d<span class="op">));</span> <span class="co">// create white circle with black background</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> glow <span class="op">=</span> <span class="fl">0.01</span><span class="op">/</span>d<span class="op">;</span> <span class="co">// create glow and diminish it with distance</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>glow <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span>glow<span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">);</span> <span class="co">// remove artifacts</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>col <span class="op">+=</span> glow<span class="op">;</span> <span class="co">// add glow</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>col<span class="op">,</span><span class="fl">1.0</span><span class="op">);</span> <span class="co">// output color</span></span></code></pre></div>
<p>Il est possible de multiplier l’effet de <em>glow</em> par une valeur
pour rendre l’objet plus lumineux pour faire en sorte que l’effet de
<em>glow</em> s’étende sur une plus grande distance (voir <a
href="#glow4" data-reference-type="ref"
data-reference="glow4">2.21</a>).</p>
<div class="sourceCode" id="cb54" data-language="GLSL"
data-caption="Intensité du glow" data-captionpos="b"
data-frame="single"><pre class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>col <span class="op">+=</span> glow <span class="op">*</span> <span class="fl">5.</span><span class="op">;</span> <span class="co">// add glow</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>col<span class="op">,</span><span class="fl">1.0</span><span class="op">);</span> <span class="co">// output color</span></span></code></pre></div>
<figure id="glow4">
<img src="images/shaders/glow3.png" />
<img src="images/shaders/glow4.png" />
<figcaption>Étendre l’effet de <em>glow</em></figcaption>
</figure>
<p>Nous venons de détailler la manière de créer un effet de
<em>glow</em> pour des formes 2D dans un <em>shader</em> en exploitant
les SDF et en instaurant un contraste entre la couleur de la forme et
celle de l’arrière-plan. De plus, nous avons généré un dégradé autour
des contours de la forme. En combinant ces deux éléments, nous avons
réussi à obtenir un effet de brillance simulé dans nos
<em>shaders</em>.</p>
<p>En 3D, le principe reste identique, à la différence près que nous
accumulons l’effet de brillance lorsque les rayons du <em>ray
marching</em> s’approchent de l’objet (voir <a href="#shadat15"
data-reference-type="ref" data-reference="shadat15">[shadat15]</a> et <a
href="#shadat14" data-reference-type="ref"
data-reference="shadat14">2.22</a>).</p>
<figure id="shadat14">
<img src="images/shaders/shaderatelier_15.jpg" />
<img src="images/shaders/shaderatelier_14.jpg" />
<figcaption>Atelier Fuz avec <em>glow</em></figcaption>
</figure>
<div class="sourceCode" id="cb55" data-language="GLSL"
data-caption="Glow 3D" data-captionpos="b" data-frame="single"><pre
class="sourceCode GLSL"><code class="sourceCode glsl"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// couleur pour le bloom</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> accCol <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.</span><span class="op">);</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co">// depart du ray marching</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span><span class="op">(</span><span class="dt">float</span> i<span class="op">=</span><span class="fl">0.</span><span class="op">;</span> i<span class="op">&lt;</span><span class="fl">128.</span><span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> res <span class="op">=</span> <span class="fu">map</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span><span class="bu">distance</span><span class="op">(</span>p<span class="op">,</span> ro<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">20.</span><span class="op">)</span> <span class="co">// astuce pour pas aller trop loin</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">break</span><span class="op">;</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>res<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="op">.</span><span class="fu">01</span><span class="op">)</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">(...)</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    p<span class="op">+=</span> rd<span class="op">*</span>res<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// accumulation du bloom</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// degrade selon l&#39;id de l objet entre rouge et bleu</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> rgb <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">,</span><span class="fl">0.</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.</span><span class="op">,</span><span class="fl">0.</span><span class="op">,</span><span class="fl">1.</span><span class="op">),</span> res<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// permet de definir ou commence ou plutot finit le bloom, ici a 1.5 de la surface</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> stBl <span class="op">=</span> <span class="op">(</span><span class="fl">1.</span><span class="op">-</span><span class="fu">sat</span><span class="op">(</span>res<span class="op">.</span><span class="fu">x</span><span class="op">/</span><span class="fl">1.5</span><span class="op">));</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>    accCol <span class="op">+=</span> rgb<span class="op">*</span><span class="fl">0.04</span><span class="op">*</span>stBl<span class="op">;</span> <span class="co">// ajout du bloom</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a><span class="co">// ajout du bloom</span></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>col <span class="op">+=</span> accCol<span class="op">;</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Nous avons initialement entrepris l’étude des techniques
fondamentales nécessaires à la programmation d’un <em>fragment
shader</em> en temps réel, avant d’approfondir notre exploration avec
des techniques avancées visant à améliorer la qualité visuelle.
Malheureusement, plusieurs concepts auraient mérité d’être mis en
lumière, notamment le Fresnel, le flou, le Truchet, les fractales, la
<em>cubemap</em>, la réflexion de la lumière, et dans le domaine sonore,
la synthèse sonore générée par les <em>shaders</em>.</p>
<p>En décrivant davantage, le Fresnel fait référence à l’interaction
optique entre la lumière et une surface, influençant la manière dont
celle-ci se réfléchit en fonction de l’angle d’incidence. Le flou, quant
à lui, représente un effet appliqué en post-traitement. Le Truchet se
rapporte à la disposition de motifs réguliers pour créer un pavage. Les
fractales sont des structures mathématiques caractérisées par leur
auto-similarité à différentes échelles. La <em>cubemap</em> est utilisée
pour simuler un environnement tridimensionnel autour d’une scène. La
réflexion de la lumière dans un contexte de <em>ray marching</em> fait
rebondir la trajectoire du rayon de manière symétrique. Enfin, la
synthèse sonore en <em>shader</em> permet d’accomplir des tâches
généralement réalisées dans des environnements tels que
SuperCollider.</p>
<p>Pour améliorer la compréhension de ces techniques non explicitées
dans le mémoire, j’ai décidé d’ajouter quelques illustrations des
ateliers correspondants, accompagnées d’un <a
href="https://wiki.fuz.re/doku.php?id=atelier:creative_coding:code_des_ateliers">lien
vers le code source commenté</a> de ces <em>shaders</em>, hébergé sur le
<a href="https://wiki.fuz.re/doku.php?id=start">wiki du Fuz</a>.</p>
<figure id="shadat12">
<img src="images/shaders/shaderatelier_06.jpg" />
<img src="images/shaders/shaderatelier_12.jpg" />
<figcaption>Réflexion sur la croix</figcaption>
</figure>
<figure id="shadat11">
<img src="images/shaders/shaderatelier_10.jpg" />
<img src="images/shaders/shaderatelier_11.jpg" />
<figcaption>Méduses avec effet de Fresnel</figcaption>
</figure>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Un <em>node</em> (nœud en français) fait référence à un
élément de base dans un système nodal ou graphique utilisé pour créer
des matériaux, des effets visuels ou des animations. Chaque
<em>node</em> représente généralement une opération spécifique ou une
partie du processus de rendu.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Un <em>pixel</em> est le plus petit élément visible à
l’écran, tandis qu’un fragment est une partie de ce <em>pixel</em>
contenant des informations détaillées comme la couleur, traitées par le
<em>fragment shader</em> pour déterminer la couleur finale du
<em>pixel</em>.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>La <em>diffuse map</em> est une texture utilisée dans le
rendu 3D pour représenter la couleur de base ou la couleur réfléchie par
un objet.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Une <em>normal map</em> est une texture utilisée dans
les graphiques 3D pour simuler des détails géométriques fins et
complexes sur une surface sans avoir à augmenter la géométrie réelle de
l’objet.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Dans le contexte des textures, on emploie plutôt le
terme <em>texel</em> que <em>pixel</em>.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Un espace orthonormé fait référence à un système de
coordonnées dans lequel les axes sont perpendiculaires (orthogonaux) les
uns aux autres et ont une longueur unitaire (normée). Cet espace est
souvent utilisé pour représenter des positions, des directions ou des
transformations dans un rendu 3D.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Un sonar, contraction de <em>SOund Navigation And
Ranging</em> en anglais, est un dispositif utilisé pour détecter et
localiser des objets sous-marins en émettant des impulsions sonores dans
l’eau et en écoutant les échos réfléchis par ces objets.<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Le lissage ou <em>smoothness</em> en infographie se
réfère généralement à la qualité visuelle d’une surface qui semble lisse
ou régulière. Cela peut être attribué à plusieurs facteurs, notamment la
quantité de détails visibles sur la surface, la régularité de ses
courbes et la manière dont elle réagit à l’éclairage.<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Un quadrant est une subdivision de l’espace en quatre
parties égales, souvent désignées comme le premier, deuxième, troisième
et quatrième quadrant, en fonction de leur position par rapport aux
axes.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Le théorème de Pythagore énonce que dans un triangle
rectangle, le carré de la longueur de l’hypoténuse (le côté opposé à
l’angle droit) est égal à la somme des carrés des longueurs des deux
autres côtés.<a href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Les fonctions de distance signée sont utilisées en
infographie et en traitement d’image pour mesurer la distance entre un
point et une surface.<a href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>La normalisation d’un vecteur est le processus de mise
à l’échelle d’un vecteur pour qu’il ait une longueur de <span
class="math inline">\(1\)</span>, tout en préservant sa direction.<a
href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Le produit vectoriel de deux vecteurs dans l’espace
tridimensionnel donne un vecteur perpendiculaire au plan formé par ces
deux vecteurs.<a href="#fnref13" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>La norme d’un vecteur, également appelée magnitude ou
longueur d’un vecteur, est une mesure de sa taille dans l’espace.<a
href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>Le gradient d’une surface est un concept mathématique
qui décrit la variation de la fonction de cette surface dans l’espace.<a
href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>En informatique graphique, le produit scalaire est une
opération mathématique fondamentale utilisée pour mesurer la similitude
directionnelle entre deux vecteurs.<a href="#fnref16"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>Deux vecteurs sont dits colinéaires s’ils sont
parallèles ou anti-parallèles, c’est-à-dire qu’ils ont la même direction
ou des directions opposées.<a href="#fnref17" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>Deux vecteurs sont dits orthogonaux s’ils sont
perpendiculaires l’un à l’autre.<a href="#fnref18" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>Une fonction <em>built-in</em> (ou fonction intégrée)
est une fonction préexistante dans un langage de programmation ou dans
un environnement de développement logiciel.<a href="#fnref19"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>Les coordonnées cartésiennes sont un système de
coordonnées dans lequel un point dans l’espace est déterminé par sa
distance par rapport à deux ou trois axes orthogonaux (perpendiculaires)
qui se croisent à un point appelé origine.<a href="#fnref20"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p>Remapper fait référence au processus de transformation
des valeurs d’un intervalle à un autre.<a href="#fnref21"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p>Le post-traitement est une technique pour appliquer des
effets visuels et des corrections à une image rendue après qu’elle ait
été traitée par les shaders de rendu principaux.<a href="#fnref22"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p>Le flou (ou <em>blur</em> en anglais) désigne une
technique graphique utilisée pour rendre une image ou une zone de
l’image moins nette ou plus douce.<a href="#fnref23"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24"><p>L’aberration chromatique se manifeste généralement par
des franges de couleur, souvent des teintes de vert, rouge et bleu,
autour des bords des objets dans une image ou une scène.<a
href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25"><p>En OpenGL, un <em>frame buffer</em> (tampon de trame en
français) est une structure de données utilisée pour stocker
temporairement les <em>pixels</em> d’une image à afficher à l’écran.<a
href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26"><p>Les L-systèmes, également connus sous le nom de
systèmes de Lindenmayer, sont des systèmes formels utilisés pour
modéliser et générer des structures fractales, notamment des formes
végétales, des motifs géométriques et d’autres formes complexes trouvées
dans la nature.<a href="#fnref26" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn27"><p>Un <em>pattern</em> désigne généralement une séquence
récurrente ou un design utilisé pour créer des effets visuels, souvent
de manière répétitive. Ces <em>patterns</em> sont souvent utilisés pour
créer des textures, des décors ou des effets visuels complexes. Ils
peuvent être générés de manière procédurale, basés sur des algorithmes,
ou créés manuellement.<a href="#fnref27" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn28"><p>Développé par Ken Perlin en 1982 pour le film « Tron »
de Disney, le bruit de Perlin produit des transitions douces entre les
valeurs, ce qui donne un aspect plus organique et réaliste aux textures
générées. Il est largement utilisé dans les domaines de l’infographie,
du rendu 3D, de la simulation et du jeu vidéo pour générer des terrains,
des nuages, des textures de bois et bien d’autres effets visuels.<a
href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29"><p>Le <em>glow</em> se réfère à un effet visuel où une
source de lumière semble émettre une lueur douce et diffuse, créant
ainsi une aura lumineuse autour de l’objet ou de la zone éclairée<a
href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30"><p>Desmos est un site web qui offre une calculatrice
graphique en ligne gratuite et puissante, ainsi que d’autres outils
mathématiques interactifs. Desmos permet de tracer des graphiques de
fonctions, des équations, des inégalités et des tableaux de données en
temps réel.<a href="#fnref30" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
