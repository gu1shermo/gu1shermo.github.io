% classe du document
\documentclass[a4paper]{report}

%====================== PACKAGES ======================

% biblio debug

% biblio
%\usepackage[backend=biber, style=authoryear, natbib=true, language=french]{biblatex}


% plusieurs bibligraphie (web, filmo etc.)
\usepackage[numbers]{natbib}
% pour les informations sur un document compilé en PDF et les liens externes / internes
\usepackage{hyperref}


\usepackage{multibib}
\newcites{books}{Bibliographie}
\newcites{web}{Webographie}

% pour les maths
% \usepackage{amsmath} 
\usepackage{amsmath}


% pour les citations
\usepackage{epigraph} 
\setlength{\epigraphrule}{0pt}
\setlength{\epigraphwidth}{0.6\textwidth}
 \renewcommand\textflush{flushepinormal}
 \renewenvironment{flushepinormal}{}{\vspace*{-\baselineskip}}

% encadrer du texte
\usepackage{awesomebox}
% \notebox
% \tipbox
% \warningbox
% \cautionbox
% \importantbox

\usepackage{fancybox}
% \shadowbox{Texte ombré.}
% \doublebox{Texte doublement encadré.}
% \ovalbox{Texte dans un cadre aux coins arrondis.}

% vertical line pour les blockquotes
\usepackage{mdframed}

% Define a new mdframed environment for blockquotes
\newmdenv[leftline=true,rightline=false,topline=false,bottomline=false]{blockquote}


% on édite en français + anglais pour l abstract
% \usepackage[french, english]{babel}
% j ai enlevé english pour avoir des césures correctes
\usepackage[french]{babel}

% \hyphenation{dé-ma-trix-age}

% \hyphenation{ci-ne-ma}

% page numeberin
\usepackage{fancyhdr}
\usepackage{lastpage}




% encodage
\usepackage[utf8]{inputenc}
% pour les commentaires avec le contexte comment
\usepackage{verbatim}
% pour générer du texte random lipsum
\usepackage{lipsum} 

% pour gérer les positionnements d'images, ça peut ne pas obéir, il vaut mieux s'en occuper à la toute fin
\usepackage{float}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}

% utiliser des liens vers des pages web
\usepackage{url}
% pour la mise en page des tableaux
\usepackage{array}
\usepackage{ }
% espacement entre les lignes
\usepackage{setspace}
% modifier la mise en page de l'abstract
\usepackage{abstract}
% police et mise en page (marges) du document
\usepackage[T1]{fontenc}

\hyphenation{ha-cker-spa-ce}
\hyphenation{dé-ma-tri-xa-ge}


\usepackage{libertine}


\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
% pour les galerie d'images
\usepackage{subfig}

% pour le glossaire et les acronymes
% \usepackage[toc,acronym]{glossaries}
%\usepackage{glossaries}

%\usepackage[acronym]{glossaries}



% pour écrire le code
\usepackage{listings}

% Ajustement de l'interligne
% \linespread{1.5}  % 1.5 correspond à un interligne de 1.5 fois l'espacement normal

% footnote numbering
% Change the numbering style of footnotes to lowercase letters
% \renewcommand{\thefootnote}{\arab{footnote}}


% lstinline custom
% Define a new command for lstinline with specified styles and color
\newcommand{\custominline}[1]{%
    \lstinline[
        basicstyle=\normalfont\ttfamily\color{black},
        keywordstyle=\normalfont\ttfamily\color{black},        
        identifierstyle=\color{black},
        stringstyle=\color{black}]|#1|%
}


% Define custom colors
\definecolor{codebackground}{RGB}{39, 40, 34}
\definecolor{codecomment}{RGB}{117, 113, 94}
\definecolor{codekeyword}{RGB}{249, 38, 114}
\definecolor{codestring}{RGB}{230, 219, 116}
\definecolor{codenumber}{RGB}{174, 129, 255}
\definecolor{codenormal}{RGB}{255, 255, 255} % Color for normal code



\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}



% coloration syntaxique pour le cpp
\lstset{
                language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#},
                belowskip=1em,
                aboveskip=2em
}

\lstdefinelanguage{GLSL}{
  morekeywords={float, vec2, vec3, vec4, mat2, mat3, mat4, int, ivec2, ivec3, ivec4, uint, uvec2, uvec3, uvec4, bool, bvec2, bvec3, bvec4, sampler1D, sampler2D, sampler3D, samplerCube, in, out, inout,texture2D},
  morekeywords=[2]{attribute, const, uniform, varying, layout, centroid, flat, smooth, noperspective, break, continue, do, for, while, switch, case, default, if, else, discard, return},
  morekeywords=[3]{in, out, inout},
  morekeywords=[4]{float, int, bool, void},
  morekeywords=[5]{true, false},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
}


\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   belowskip=1em,
   aboveskip=2em
}




\lstset{
  language=GLSL,
  basicstyle=\ttfamily\small\color{codenormal}, % Color for normal code
  % basicstyle=\ttfamily\small,
  % backgroundcolor=\color{gray!10},
  backgroundcolor=\color{codebackground},
  keywordstyle=\color{codekeyword}\bfseries,
  identifierstyle=\color{codenormal}, % Color for variables
  % keywordstyle=[1]\color{codekeyword}\bfseries,
  % keywordstyle=[2]\color{codekeyword},
  % keywordstyle=[3]\color{codekeyword},
  % keywordstyle=[4]\color{codekeyword}\bfseries,
  % keywordstyle=[5]\color{codekeyword},
  commentstyle=\color{codecomment}\itshape,
  stringstyle=\color{codestring},
  numberstyle=\tiny\color{codenumber},
  showstringspaces=false,
  breaklines=true,
  tabsize=2,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  frame=lines,
  xleftmargin=15pt,
  framexleftmargin=15pt,
  captionpos=b,
  belowskip=1em,
  aboveskip=2em,
}

% \input{glossary.tex}
% \input{acronyms.tex}






%====================== INFORMATION ET REGLES ======================

%rajouter les numérotation pour les \paragraphe et \subparagraphe
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

% META DATA du pdf
\hypersetup{							% Information sur le document
	pdfauthor = {Guillaume Cournet},
	% Auteurs
	pdftitle = {Vers une interaction authentique entre live coders : rendre la musique tangible},			% Titre du document
	pdfsubject = {Vers une interaction authentique entre live coders : rendre la musique tangible},		% Sujet
	pdfkeywords = {livecoding, demoscene, algorave, fragment shaders, pipeline, Orca, FoxDot},	% Mots-clefs
	pdfstartview={FitH},
	bookmarksnumbered=true,}
% ajuste la page à la largueur de l'écran
%pdfcreator = {MikTeX},% Logiciel qui a crée le document
%pdfproducer = {}} % Société avec produit le logiciel

%======================== DEBUT DU DOCUMENT ========================


% \newcommand{\lstinlineplain}[1]{\lstinline[basicstyle=\ttfamily, stringstyle=\ttfamily]{#1}}
\renewcommand{\chaptername}{Chapitre}
%régler l'espacement entre les lignes
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

% recommencer la numérotation des pages à "1"

% \pagestyle{empty}
% page de garde
\input{./title.tex}

\newpage
\thispagestyle{empty}
\mbox{} % Empty content to ensure the page is not totally empty
\newpage
\clearpage

\pagestyle{empty}
% remerciements
\input{./abstract.tex}
\input{./greetings.tex}

% résumé


\setcounter{page}{1}


% preambule
\input{./preambule.tex}





%====================== INCLUSION DES PARTIES ======================

~
\pagestyle{plain}




%\pagestyle{plain}  % Choose a plain page style
% pagination
\pagestyle{fancy}
\fancyhf{}  % Clear header and footer
\fancyfoot[R]{- \thepage\ / \pageref{LastPage} -}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% Adjust left margin of footer
\setlength{\footskip}{25pt} % Adjust as needed
% \lfoot{\thepage}

% Ajustement de l'interligne
% \linespread{1.5}  % 1.5 correspond à un interligne de 1.5 fois l'espacement normal

% La valeur actuelle de \textbackslash baselineskip est : \the\baselineskip.


% include d'autres fichiers .tex situés à la racine
%\chapter{TODO}
%\listoftodos[Liste TODO]

% \todo{démocratisation de la demoscene}
% \todo{2 machines en réseau}
% \todo{de l'invisible (musique FoxDot) vers le visible (fragment shader)}
% \todo{algorithmes appliqués à la musique}
% \todo{citation d'introduction}
% \todo{ajouter mots clés ds le template}



%page blanche
% \newpage  
~
%ne pas numéroter cette page
\thispagestyle{empty}
\newpage



% TOC
% \todo{alléger , enlever les subsections}
\renewcommand{\contentsname}{Table des matières}
\tableofcontents
\newpage
\thispagestyle{empty}
% ne pas paginer 
% \setcounter{page}{0}

\newpage

%espacement entre les lignes d'un tableau
\renewcommand{\arraystretch}{1.5}


% **INTRODUCTION**
\input{./introduction.tex}
% **DEMOSCENE**
\input{./demoscene.tex}

% **PIPELINE**
\input{./pipeline.tex}
% **SHADERS**
\input{./shaders.tex}
% **MUSIQUE ALGORTIHMIQUE**
\input{./music_algo.tex}
% **Experimentations**
\input{./experiments.tex}
% **CONCLUSION**
\input{./conclusion.tex}

\newpage

%récupérer les citation avec "/footnotemark"
\nocite{*}

\nocitebooks{*}
\nociteweb{*}

%choix du style de la biblio
% biblio avec un nouveau nom ds la table des matières
\bibliographystylebooks{plain}
\addcontentsline{toc}{part}{Bibliographie}
\bibliographybooks{bibliographie.bib}
%\printbibliography
%\bibliographystyle{plain}
\bibliographystyleweb{plainnat}
\addcontentsline{toc}{part}{Webographie}
\bibliographyweb{webographie}

%\bibliographystyle{plain}
%\addcontentsline{toc}{part}{Filmographie}
%\bibliography{filmographie}



% liste des illustrations
\addcontentsline{toc}{part}{Liste des illustrations}
\renewcommand{\listfigurename}{Liste des illustrations}
\listoffigures


% comment utiliser le glossaire

% Voici un exemple d'utilisation de \gls{latex}.
% Voici un exemple d'utilisation de \gls{raytracing}.
% Voici un exemple d'utilisation de \gls{raymarching}.
% Voici un exemple d'utilisation de \gls{raycasting}.
% imprimer le glossaire
%\printglossaries

% \printglossary[title=Glossaire, toctitle=Glossaire]
% \printglossary[type=\acronymtype,title=Acronymes, toctitle=Acronymes]

% ANNEXES
\appendix
\addcontentsline{toc}{chapter}{\large Annexes}
\renewcommand{\thechapter}{\Alph{chapter}}\renewcommand{\thesection}{\Roman{section}}
\renewcommand{\thesubsection}{\fnsymbol{subsection}}

\chapter{Liste opérateurs Orca}\label{appendix:orcaops}

\section*{En anglais}

\begin{itemize}
  \item \textbf{A} : add(a b) -- Outputs sum of inputs.
  \item \textbf{B} : subtract(a b) -- Outputs difference of inputs.
  \item \textbf{C} : clock(rate mod) -- Outputs modulo of frame.
  \item \textbf{D} : delay(rate mod) -- Bangs on modulo of frame.
  \item \textbf{E} : east -- Moves eastward, or bangs.
  \item \textbf{F} : if(a b) -- Bangs if inputs are equal.
  \item \textbf{G} : generator(x y len) -- Writes operands with offset.
  \item \textbf{H} : halt -- Halts southward operand.
  \item \textbf{I} : increment(step mod) -- Increments southward operand.
  \item \textbf{J} : jumper(val) -- Outputs northward operand.
  \item \textbf{K} : konkat(len) -- Reads multiple variables.
  \item \textbf{L} : lesser(a b) -- Outputs smallest of inputs.
  \item \textbf{M} : multiply(a b) -- Outputs product of inputs.
  \item \textbf{N} : north -- Moves Northward, or bangs.
  \item \textbf{O} : read(x y read) -- Reads operand with offset.
  \item \textbf{P} : push(len key val) -- Writes eastward operand.
  \item \textbf{Q} : query(x y len) -- Reads operands with offset.
  \item \textbf{R} : random(min max) -- Outputs random value.
  \item \textbf{S} : south -- Moves southward, or bangs.
  \item \textbf{T} : track(key len val) -- Reads eastward operand.
  \item \textbf{U} : uclid(step max) -- Bangs on Euclidean rhythm.
  \item \textbf{V} : variable(write read) -- Reads and writes variable.
  \item \textbf{W} : west -- Moves westward, or bangs.
  \item \textbf{X} : write(x y val) -- Writes operand with offset.
  \item \textbf{Y} : jymper(val) -- Outputs westward operand.
  \item \textbf{Z} : lerp(rate target) -- Transitions operand to input.
  \item \textbf{*} : bang -- Bangs neighboring operands.
  \item \textbf{\#} : comment -- Halts a line.
  \item \textbf{:} : midi(channel octave note velocity length) -- Sends a MIDI note.
  \item \textbf{\%} : mono(channel octave note velocity length) -- Sends monophonic MIDI note.
  \item \textbf{!} : cc(channel knob value) -- Sends MIDI control change.
  \item \textbf{?} : pb(channel value) -- Sends MIDI pitch bend.
  \item \textbf{;} : udp -- Sends UDP message.
  \item \textbf{=} : osc(path) -- Sends OSC message.
  \item \textbf{\$} : self -- Sends ORCA commands.
\end{itemize}

\newpage
\section*{En français}

\begin{itemize}
\item \textbf{A} : add(a b) -- Renvoie la somme des entrées.
\item \textbf{B} : subtract(a b) -- Renvoie la différence des entrées.
\item \textbf{C} : clock(rate mod) -- Renvoie le modulo de la \textit{frame}.
\item \textbf{D} : delay(rate mod) -- Déclenche un \textit{bang} sur le modulo de la \textit{frame}.
\item \textbf{E} : east -- Se déplace vers l'est, ou déclenche un \textit{bang}.
\item \textbf{F} : if(a b) -- Déclenche si les entrées sont égales.
\item \textbf{G} : generator(x y len) -- Écrit les opérandes avec un \textit{offset}.
\item \textbf{H} : halt -- Arrête l'opérateur Sud.
\item \textbf{I} : increment(step mod) -- Incrémente l'opérateur Sud.
\item \textbf{J} : jumper(val) -- Renvoie l'opérande vers le nord.
\item \textbf{K} : konkat(len) -- Lit plusieurs variables.
\item \textbf{L} : lesser(a b) -- Renvoie la plus petite des entrées.
\item \textbf{M} : multiply(a b) -- Renvoie le produit des entrées.
\item \textbf{N} : north -- Se déplace vers le nord, ou déclenche un \textit{bang}.
\item \textbf{O} : read(x y read) -- Lit l'opérande avec un décalage.
\item \textbf{P} : push(len key val) -- Écrit l'opérande vers l'est.
\item \textbf{Q} : query(x y len) -- Lit les opérandes avec un décalage.
\item \textbf{R} : random(min max) -- Renvoie une valeur aléatoire.
\item \textbf{S} : south -- Se déplace vers le sud, ou déclenche un \textit{bang}.
\item \textbf{T} : track(key len val) -- Lit l'opérande vers l'est.
\item \textbf{U} : uclid(step max) -- Déclenche sur un rythme euclidien.
\item \textbf{V} : variable(écrire lire) -- Lit et écrit une variable.
\item \textbf{W} : west -- Se déplace vers l'ouest, ou déclenche un \textit{bang}.
\item \textbf{X} : write(x y val) -- Écrit l'opérande avec un décalage.
\item \textbf{Y} : jymper(val) -- Renvoie l'opérande vers l'ouest.
\item \textbf{Z} : lerp(rate target) -- Transitions de l'opérande vers l'entrée.
\item \textbf{*} : bang -- Déclenche les opérandes voisines.
\item \textbf{\#} : comment -- Arrête une ligne.
\item \textbf{:} : midi(canal octave note vélocité durée) -- Envoie une note MIDI.
\item \textbf{\%} : mono(canal octave note vélocité durée) -- Envoie une note MIDI monophonique.
\item \textbf{!} : cc(canal bouton valeur) -- Envoie un message de changement de contrôle MIDI.
\item \textbf{?} : pb(canal valeur) -- Envoie un message de pitch bend MIDI.
\item \textbf{;} : udp -- Envoie un message UDP.
\item \textbf{=} : osc(chemin) -- Envoie un message OSC.
\item \textbf{\$} : self -- Envoie des commandes ORCA.
\end{itemize}




\chapter{Code C/C++ pour composer de la musique}\label{appendix:codemidi}

\begin{lstlisting}[language=C++, caption=CPP MIDI,captionpos=b]
#include <vector>   // For std::vector<>
#include <cstring>  // For std::strlen()
#include <cstdio>   // For std::fopen(), std::fwrite(), std::fclose()

typedef unsigned char byte;

/* First define a custom wrapper over std::vector<byte>
 * so we can quickly push_back multiple bytes with a single call.
 */
class MIDIvec: public std::vector<byte>
{
public:
    // Methods for appending raw data into the vector:
    template<typename... Args>
    void AddBytes(byte data, Args...args)
    {
        push_back(data);
        AddBytes(args...);
    }
    template<typename... Args>
    void AddBytes(const char* s, Args...args)
    {
        insert(end(), s, s + std::strlen(s));
        AddBytes(args...);
    }
    void AddBytes() { }
};

/* Define a class which encodes MIDI events into a track */
class MIDItrack: public MIDIvec
{
protected:
    unsigned delay, running_status;
public:
    MIDItrack()
        : MIDIvec(), delay(0), running_status(0)
    {
    }
    
    // Methods for indicating how much time elapses:
    void AddDelay(unsigned amount) { delay += amount; }
    
    void AddVarLen(unsigned t)
    {
        if(t >> 21) AddBytes(0x80 | ((t >> 21) & 0x7F));
        if(t >> 14) AddBytes(0x80 | ((t >> 14) & 0x7F));
        if(t >>  7) AddBytes(0x80 | ((t >>  7) & 0x7F));
        AddBytes(((t >> 0) & 0x7F));
    }
    
    void Flush()
    {
        AddVarLen(delay);
        delay = 0;
    }
    
    // Methods for appending events into the track:
    template<typename... Args>
    void AddEvent(byte data, Args...args)
    {
        /* MIDI tracks have the following structure:
         *
         * { timestamp [metaevent ... ] event } ...
         *
         * Each event is prefixed with a timestamp,
         * which is encoded in a variable-length format.
         * The timestamp describes the amount of time that
         * must be elapsed before this event can be handled.
         *
         * After the timestamp, comes the event data.
         * The first byte of the event always has the high bit on,
         * and the remaining bytes always have the high bit off.
         *
         * The first byte can however be omitted; in that case,
         * it is assumed that the first byte is the same as in
         * the previous command. This is called "running status".
         * The event may furthermore beprefixed
         * with a number of meta events.
         */
       Flush();
       if(data != running_status) AddBytes(running_status = data);
       AddBytes(args...);
    }
    void AddEvent() { }
    
    template<typename... Args>
    void AddMetaEvent(byte metatype, byte nbytes, Args...args)
    {
        Flush();
        AddBytes(0xFF, metatype, nbytes, args...);
    }
    
    // Key-related parameters: channel number, note number, pressure
    void KeyOn(int ch, int n, int p)    { if(n>=0)AddEvent(0x90|ch, n, p); }
    void KeyOff(int ch, int n, int p)   { if(n>=0)AddEvent(0x80|ch, n, p); }
    void KeyTouch(int ch, int n, int p) { if(n>=0)AddEvent(0xA0|ch, n, p); }
    // Events with other types of parameters:
    void Control(int ch, int c, int v) { AddEvent(0xB0|ch, c, v); }
    void Patch(int ch, int patchno)    { AddEvent(0xC0|ch, patchno); }
    void Wheel(int ch, unsigned value)
        { AddEvent(0xE0|ch, value&0x7F, (value>>7)&0x7F); }
    
    // Methods for appending metadata into the track:
    void AddText(int texttype, const char* text)
    {
        AddMetaEvent(texttype, std::strlen(text), text);
    }
};

/* Define a class that encapsulates all methods needed to craft a MIDI file. */
class MIDIfile: public MIDIvec
{
protected:
    std::vector<MIDItrack> tracks;
    unsigned deltaticks, tempo;
public:
    MIDIfile()
        : MIDIvec(), tracks(), deltaticks(1000), tempo(1000000)
    {
    }
    
    void AddLoopStart()  { (*this)[0].AddText(6, "loopStart"); }
    void AddLoopEnd()    { (*this)[0].AddText(6, "loopEnd"); }
    
    MIDItrack& operator[] (unsigned trackno)
    {
        if(trackno >= tracks.size())
        {
            tracks.reserve(16);
            tracks.resize(trackno+1);
        }
        
        MIDItrack& result = tracks[trackno];
        if(result.empty())
        {
            // Meta 0x58 (misc settings):
                //      time signature: 4/2
                //      ticks/metro:    24
                //      32nd per 1/4:   8
            result.AddMetaEvent(0x58,4,  4,2, 24,8);
            // Meta 0x51 (tempo):
            result.AddMetaEvent(0x51,3,  tempo>>16, tempo>>8, tempo);
        }
        return result;
    }
    
    void Finish()
    {
        clear();
        AddBytes(
            // MIDI signature (MThd and number 6)
            "MThd", 0,0,0,6,
            // Format number (1: multiple tracks, synchronous)
            0,1,
            tracks.size() >> 8, tracks.size(),
            deltaticks    >> 8, deltaticks);
        for(unsigned a=0; a<tracks.size(); ++a)
        {
            // Add meta 0x2F to the track, indicating the track end:
            tracks[a].AddMetaEvent(0x2F, 0);
            // Add the track into the MIDI file:
            AddBytes("MTrk",
                tracks[a].size() >> 24,
                tracks[a].size() >> 16,
                tracks[a].size() >>  8,
                tracks[a].size() >>  0);
            insert(end(), tracks[a].begin(), tracks[a].end());
        }
    }
};

int main()
{
    // Now that we have a class that can create MIDI files, let's create
    // music.
    
    // Begin with some chords.
    static const int chords[][3] =
    {
        { 12,4,7 }, // +C  E  G  = 0
        { 12,9,5 }, // +C  A  F  = 1
        { 12,8,3 }, // +C  G# D# = 2
        { 12,7,3 }, // +C  G  D# = 3
        { 12,5,8 }, // +C  F  G# = 4
        { 12,3,8 }, // +C  D# G# = 5
        { 11,2,7 }, //  B  D  G  = 6
        { 10,2,7 }, // A#  D  G  = 7
        { 14,7,5 }, // +D  G  F  = 8
        { 14,7,11 },// +D  G  B  = 9
        { 14,19,11 }// +D +G  B  = 10
    };
    const char x = 99; // Arbitrary value we use here to indicate "no note"
    static const char chordline[64] =
    {
        0,x,0,0,x,0,x, 1,x,1,x,1,1,x,1,x,  2,x,2,2,x,2,x, 3,x,3,x,3,3,x,3,x,
        4,x,4,4,x,4,x, 5,x,5,x,5,5,x,5,x,  6,7,6,x,8,x,9,x,10,x,x,x,x,x,x,x
    };
    static const char chordline2[64] =
    {
        0,x,x,x,x,x,x, 1,x,x,x,x,x,x,x,x,  2,x,x,x,x,x,x, 3,x,x,x,x,x,x,x,x,
        4,x,x,x,x,x,x, 5,x,x,x,x,x,x,x,x,  6,x,x,x,x,x,x,x, 6,x,x,x,x,x,x,x
    };
    static const char bassline[64] =
    {
        0,x,x,x,x,x,x, 5,x,x,x,x,x,x,x,x,  8,x,x,0,x,3,x, 7,x,x,x,x,x,x,x,x,
        5,x,x,x,x,x,x, 3,x,x,x,x,x,x,x,x,  2,x,x,x,x,x,x,-5,x,x,x,x,x,x,x,x
    };
    static const char fluteline[64] =
    {
        12,x,12,12, x,9, x, 17,x,16,x,14,x,12,x,x,
         8,x, x,15,14,x,12,  x,7, x,x, x,x, x,x,x,
         8,x, x, 8,12,x, 8,  x,7, x,8, x,3, x,x,x,
         5,x, 7, x, 2,x,-5,  x,5, x,x, x,x, x,x,x
    };
    
    MIDIfile file;
    file.AddLoopStart();
    
    /* Choose instruments ("patches") for each channel: */
    static const char patches[16] =
    {
        0,0,0, 52,52,52, 48,48,48, 0,0,0,0,0, 35,74
        /* 0=piano, 52=choir aahs, 48=strings, 35=fretless bass, 74=pan flute */
    };
    for(unsigned c=0; c<16; ++c)
        if(c != 10) // Patch any other channel but not the percussion channel.
            file[0].Patch(c, patches[c]);
    
    int keys_on[16] = {-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1 };
    for(unsigned loops=0; loops<2; ++loops)
    {
        for(unsigned row=0; row<128; ++row)
        {
            for(unsigned c=0; c<16; ++c)
            {
                int note = x, add = 0, vol = 127;
                if(c < 3) // Piano chord
                  { int chord = chordline[row%64];
                    if(chord != x) note = chords[chord][c%3], add=12*5, vol=0x4B; }
                else if(c >= 3 && c < 5) // Aux chord (choir)
                  { int chord = chordline2[row%64];
                    if(chord != x) note = chords[chord][c%3], add=12*4, vol=0x50; }
                else if(c >= 6 && c < 8) // Aux chord (strings)
                  { int chord = chordline2[row%64];
                    if(chord != x) note = chords[chord][c%3], add=12*5, vol=0x45; }
                else if(c == 14) // Bass
                    note = bassline[row%64], add=12*3, vol=0x6F;
                else if(c == 15 && row >= 64) // Flute
                    note = fluteline[row%64], add=12*5, vol=0x6F;
                if(note == x && (c<15 || row%31)) continue;
                file[0].KeyOff(c, keys_on[c], 0x20);
                keys_on[c] = -1;
                if(note == x) continue;
                file[0].KeyOn(c, keys_on[c] = note+add, vol);
            }
            file[0].AddDelay(160);
        }
        if(loops == 0) file.AddLoopEnd();
    }
    
    file.Finish();
    
    FILE* fp = std::fopen("test.mid", "wb");
    std::fwrite(&file.at(0), 1, file.size(), fp);
    std::fclose(fp);
    
    return 0;
}
\end{lstlisting}

\chapter{Signaux MIDI}\label{appendix:midi}

\section*{\textit{Note On} et \textit{Note Off}}
Les messages \textit{Note On} et \textit{Note Off} sont fondamentaux en MIDI pour la gestion des notes jouées. Le message « Note On » informe sur la touche pressée, sa vélocité et le canal MIDI concerné. Il est composé d'un octet de statut commençant par $1001$, suivi de deux octets de données : le premier pour la note jouée et le second pour la vélocité. Le message \textit{Note Off}, quant à lui, indique la libération d'une touche avec les mêmes détails que \textit{Note On}, mais avec un statut différent commençant par $1000$ (pour rappel, à chaque fois le $1$ est là pour préciser qu'il s'agit d'un octet de statut).
Par exemple, voici les représentations d'un message \textit{Note On} qui jouerait un Do avec une vélocité maximale et celui d'un message \textit{Note Off} qui lui ferait miroir:

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=\textit{Note On},captionpos=b,frame=single] 
Note On : 0x9n (1001 nnnn)
Exemple : 0x90 0x3C 0x7F
0x90 (1001 0000) : Note On sur le canal MIDI 1
0x3C (0011 1100) : Note numero 60 (Do central)
0x7F (0111 1111) : Velocite maximale (127)
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=\textit{Note Off},captionpos=b,frame=single] 
Note Off : 0x8n (1000 nnnn)
Exemple : 0x80 0x3C 0x40
0x80 (1000 0000) : Note Off sur le canal MIDI 1
0x3C (0011 1100) : Note numero 60 (Do central)
0x40 (0100 0000) : Velocite 64 (valeur typique pour un Note Off)
\end{lstlisting}
\end{minipage}


L'information de vélocité est intégrée dans les messages « Note On » et « Note Off », reflétant la vitesse à laquelle une touche est relâchée.

\section*{\textit{Aftertouch Polyphonic} et \textit{Aftertouch Channel}}

Les messages \textit{Aftertouch}, qu'ils soient \textit{Polyphonic} ou \textit{Channel}, renvoient des informations sur la pression appliquée sur une touche après l'émission initiale. Bien que cette caractéristique ne soit pas présente dans les pianos mécaniques, elle trouve son utilité dans d'autres instruments comme les instruments à vent ou à cordes. 

Le \textit{Polyphonic Aftertouch} envoie la pression individuelle pour chaque touche pressée, nécessitant donc trois octets par note.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=\textit{Aftertouch} Polyphonique,captionpos=b,frame=single] 
Aftertouch Polyphonique : 0xAn (1010 nnnn)
Exemple : 0xA0 0x3C 0x40
0xA0 (1010 0000) : Aftertouch Polyphonique sur le canal MIDI 1
0x3C (0011 1100) : Note numero 60 (Do central)
0x40 (0100 0000) : Pression de la touche
\end{lstlisting}
\end{minipage}

Par contre le \textit{Channel Aftertouch} envoie uniquement la pression de la touche avec la pression la plus élevée, nécessitant seulement deux octets.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=\textit{Aftertouch} de canal,captionpos=b,frame=single] 
Aftertouch de canal (Channel Aftertouch) : 0xDn (1101 nnnn)
Exemple : 0xD0 0x40
0xD0 (1101 0000) : Aftertouch de canal sur le canal MIDI 1
0x40 (0100 0000) : Pression de la touche
\end{lstlisting}
\end{minipage}

\section*{Changement de contrôle (\textit{Control Change})}
Le message \textit{Control Change} transmet des informations sur les contrôleurs tels que les boutons, pédales et curseurs. Ce message est constitué d'un octet de statut avec un préfixe $1011$, suivi du canal, du numéro du contrôleur, et de la valeur (de $0$ à $127$).

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=Changement de contrôle,captionpos=b,frame=single]
Changement de controle (Control Change) : 0xB0 (1011 nnnn)
Exemple : 0xB0 0x07 0x64
0xB0 (1011 0000) : Controle de changement sur le canal MIDI 1
0x07 (0000 0111) : Numero de controleur (ici, le controle de volume)
0x64 (0110 0100) : Valeur du controle (100 en decimal, indiquant le volume a 100)
\end{lstlisting}
\end{minipage}

\section*{Changement de Programme (\textit{Program Change})}

Bien que considéré comme une relique des débuts des synthétiseurs logiciels, le message \textit{Program Change} était utilisé pour signaler les changements de patch. À l'origine, avec $127$ voix disponibles dans tous les synthétiseurs MIDI, ce système était particulièrement adapté aux jeux vidéo, permettant une expérience musicale cohérente sur différents matériels. Ces $127$ voix incluent également des effets sonores comme le chant des oiseaux ou le bruit de téléphone. Les messages \textit{Program Change} se composent de deux octets : un octet de statut commençant par $1100$, indiquant le canal, suivi d'un octet de données désignant le nouvel instrument.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=Changement de programme,captionpos=b,frame=single]
Changement de programme (Program Change) : 0xCn (1100 nnnn)
Exemple : 0xC0 0x04
0xC0 (1100 0000) : Changement de programme sur le canal MIDI 1
0x04 (0000 0100) : Programme numero 5
\end{lstlisting}
\end{minipage}

\section*{\textit{Pitch Bend}}

Le \textit{Pitch Bend} se distingue des autres contrôleurs continus par sa résolution plus élevée dans le protocole MIDI. Au lieu d'utiliser une plage de valeurs de $0$ à $127$, le \textit{Pitch Bend} utilise deux octets pour fournir une résolution de 14 bits, offrant $16384$ ($2^14$) valeurs possibles. Cette précision est essentielle pour un contrôle microtonal détaillé, ce qui est particulièrement utile pour des données à haute résolution dans le protocole MIDI.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=GLSL, caption=Pitch Bend,captionpos=b,frame=single]
Pitch Bend : 0xEn (1110 nnnn)
Exemple : 0xE0 0x00 0x40
0xE0 (1110 0000) : Pitch Bend sur le canal MIDI 1
0x00 0x40 (0000 0000 0100 0000) : Valeur du pitch bend (vers le haut)
\end{lstlisting}
\end{minipage}










% **FoxDot**
% \input{./foxdot.tex}






% \chapter{Entretiens}
% \todo{préparer une liste de questions}
% \todo{s inspirer de la chaine curious minded shaders}

% \section{Entretien avec z0rg}
% \begin{center}
% \fbox{
%   \begin{minipage}{0.8\textwidth}
    
%         \noindent
%         \textbf{Date:} Lundi 12 avril 2021 \\
%         \textbf{Durée:} 1 heure 21 minutes \\
%         \textbf{Entretien semi-directif (?) en distanciel} format proposé pour l'interviewé \\
%         \textbf{Profil:} Léa est artiste... \\
%         son site professionnel : \url{google.fr}\\
%         \textbf{Retranscription:} reformulations de phrases, supprimer répétitions hésitations\\
%         \textbf{En gras mes questions}
%   \end{minipage}
% }
% \end{center}

% \noindent

% \textbf{How did you start your career in programming?} 
% \begin{blockquote}
% This is a blockquote in LaTeX.
% It can span multiple lines.
% \end{blockquote}

\end{document}